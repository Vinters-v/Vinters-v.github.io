<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DC综合环境的搭建</title>
    <link href="/2024/09/24/%E6%95%B0%E5%AD%97IC_DC%E7%BB%BC%E5%90%88/"/>
    <url>/2024/09/24/%E6%95%B0%E5%AD%97IC_DC%E7%BB%BC%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>简单介绍DC的综合环境的搭建</p><span id="more"></span><h1 id="DC"><a href="#DC" class="headerlink" title="DC"></a>DC</h1><p>综合过程</p><ol><li>将RTL映射为通用单元，例如将&amp;映射为与门。与Foundary、工艺有关。</li><li>将通用单元映射为标准单元库中的元器件。与Foundary、工艺有关。</li></ol><p>从EDA工作机理分为三步，analyze、elaborate、compile，其中analyze和elaborate对应于步骤1，compile对应于步骤2。</p><h2 id="综合脚本"><a href="#综合脚本" class="headerlink" title="综合脚本"></a>综合脚本</h2><p>命令<strong>set_app_var</strong>用于声明不同的<strong>内部变量</strong>。</p><p><strong>search_path</strong>：用于提供工具寻找文件的路径。</p><p>除了RTL之外，其他器件如SRAM、ROM、元器件库等都使用db文件保存，它是一种二进制文件。</p><p>元器件库包括标准单元库和引脚单元库，芯片设计中它们的电平标准可能存在差别。</p><p><strong>synthetic_library</strong>：装载模型库，即综合过程步骤1中的库，一般使用DC工具提供的DesignWare模型。</p><p><strong>target_library</strong>：用于指定元器件库，即综合过程步骤2中的库。</p><p><strong>link_library</strong>：用于将物理相关的路径进行汇总，其中*表示该变量内部原来的默认值。</p><h3 id="syn-tcl"><a href="#syn-tcl" class="headerlink" title="syn.tcl"></a>syn.tcl</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-comment">###############################################################################################################</span><br><span class="hljs-comment">##搭建综合环境</span><br><br>set_app_var search_path [<span class="hljs-keyword">concat</span> . \<br>RTL 路径<span class="hljs-number">1</span>                     \<br>RTL 路径<span class="hljs-number">2</span>                     \<br>SRAM 路径                     \<br>ROM 路径                      \<br>标准单元库路径                 \<br>引脚单元库路径                 <br>]<br>set_app_var synthetic_library dw_foundation.sldb #DC在run时会自动加载，脚本中可以不写<br>set_app_var target_library [<span class="hljs-keyword">concat</span> 标准单元库文件名.db \<br>引脚单元库名.db                                   \<br>SRAM 文件名.db                                    \<br>ROM 文件名.db<br>]<br>set_app_var link_library [<span class="hljs-keyword">concat</span> * <span class="hljs-variable">$synthetic_library</span> <span class="hljs-variable">$target_library</span>] #表示原来的默认值并增加另外两个路径<br>set_app_var cache_read 路径 A1 #设置综合时存储临时文件的地址（与DesignWare相关），读路径<br>set_app_var cache_write 路径 A2 #写路径，可以建立一个目录存放<br>set_host_options -max_cores <span class="hljs-number">8</span>  #用于指定服务器中使用的CPU核数<br>set_app_var hdlin_vrlg_std <span class="hljs-number">2005</span> #用于指定RTL所使用的语法标准，一般使用Verilog<span class="hljs-number">-2001</span>或者<span class="hljs-number">-2005</span><br>set_app_var compile_seqmap_propagate_constants false #设置不要对设计中的常数进行优化，即不要删除一些相同的参数<br>set_app_var power_cg_auto_identify true #设置允许工具在读取RTL时自动识别其中的时钟门控，对降低芯片的功耗有帮助<br>set_app_var hdlin_check_no_latch true #设置工具发现锁存器后报警<br>define_design_lib work -path 路径 A2 #指定路径将综合中elaborate步骤产生的临时二进制文件存放<br><span class="hljs-keyword">set</span> rtl_files <span class="hljs-string">&quot;rtl1.v rtl2.v rtl3.v&quot;</span> #将所有RTL文件名放入一个自命名的变量中，rtl_file任意取<br><br><span class="hljs-comment">###############################################################################################################</span><br><span class="hljs-comment">##综合步骤（analyze、elaborate、compile）</span><br><br>analyze -<span class="hljs-keyword">format</span> sv <span class="hljs-variable">$rtl_files</span> //读入RTL代码并进行分析，使用标准SV语法<br>elaborate design_top //此处design_top应为RTL设计中顶层模块名<br><span class="hljs-keyword">source</span> -v timing.sdc //读取时序约束<br><span class="hljs-comment">##对信号时序路径的分组和命名，reg2reg表示从寄存器到寄存器的路径</span><br><span class="hljs-comment">##weight表示权重，权重越大，工具会消耗更多的算力优化，其他权重默认为1</span><br>group_path -name reg2reg -from [all_registers] -to [all_registers] -weight <span class="hljs-number">20</span><br>group_path -name in2reg -from [all_inputs] -to [all_registers]<br>group_path -name reg2out -from [all_registers] -to [all_outputs]<br>group_path -name in2out -from [all_inputs] -to [all_outputs]<br>uniquify //唯一化，为每一个例化的子模块都生成独立的逻辑实体<br>compile_ultra -gate_clock #允许在综合过程中自动识别并插入时钟门控<br><span class="hljs-comment">#compile_ultra -gate_clock -scan #插入DFT的Scan链，综合时选择带有Scan功能的元器件</span><br>define_name_rules simple_names -type net -allowed <span class="hljs-string">&quot;A-Za-z0-9_\[\]&quot;</span> -first_restricted <span class="hljs-string">&quot;0-9_&quot;</span> #修改线路名字<br>define_name_rules simple_names -type port -allowed <span class="hljs-string">&quot;A-Za-z0-9_\[\]&quot;</span> -first_restricted <span class="hljs-string">&quot;0-9_&quot;</span><br>define_name_rules simple_names -type cell -allowed <span class="hljs-string">&quot;A-Za-z0-9_&quot;</span> -first_restricted <span class="hljs-string">&quot;0-9_&quot;</span><br>define_name_rules simple_names -special verilog -map &#123; &#123;&#123;<span class="hljs-string">&quot;\\\\ * cell \\\\*&quot;</span>, <span class="hljs-string">&quot;U&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;&amp; -return&quot;</span>, <span class="hljs-string">&quot;RET&quot;</span>&#125;&#125; &#125;<br>change_names -rules simple_names -hierarchy -v #让新定义的simple_names生效<br>write -hierachy -<span class="hljs-keyword">format</span> verilog -output design.v #输出网表文件<br>write -hierachy -<span class="hljs-keyword">format</span> verilog -output dedign.ddc #保存本次综合的信息以便下次使用，可以使用read_ddc读取 <br>report_timing -max_paths <span class="hljs-number">10</span> -delay_type max &gt; timing.rpt #时序报告 每个路径组报告<span class="hljs-number">10</span>条路径，只报告建立时间分析结果<br><span class="hljs-comment">#report_timing -max_paths 10 -delay_type min &gt; timing.rpt #报告保持时间</span><br>report_area -physical -nosplit &gt; area.rpt #输出面积报告<br>report_qor -nosplit &gt; qor.rpt #将综合结果汇总为一个质量报告输出<br>report_clock_gating -nosplit &gt; clock_gating.rpt #报告时钟门控覆盖率<br><br></code></pre></td></tr></table></figure><p>注：</p><p>自动插入时钟门控，既可以节省功耗，还能减少元器件的使用，从而减少面积。</p><p>插入时钟门控的原理是寻找时序逻辑的if语句，如果只写了else if （vld）, 或者使用else写了保持逻辑，则说明可以直接插入时钟门控。</p><p>下面的时序逻辑，在实际综合时，会将vld直接作为时钟门控开关，直接控制clk，当vld为1时，时钟通入。节省了动态功耗和元器件。</p><p>综合时常常会统计时序逻辑的门控比例，一般要求不低于95%，能插入尽量插入。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(!rst)<br>        dout &lt;= <span class="hljs-number">8&#x27;d0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vld)<br>        dout &lt;= din;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//(可以省略不写)</span><br>        dout &lt;= dout;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>将上述脚本保存为一个文本文件，syn.tcl，运行以下命令进行综合，其中| tee dc.log表示将综合信息打印到dc.log文件中。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tcl">dc_shell -f syn.tcl | tee dc.log<br></code></pre></td></tr></table></figure><h2 id="时序分析"><a href="#时序分析" class="headerlink" title="时序分析"></a>时序分析</h2><h2 id="时序约束"><a href="#时序约束" class="headerlink" title="时序约束"></a>时序约束</h2><p><strong>create clock</strong>：声明一个从外部来的时钟，-name是时钟命名，在综合工具中使用，可以与RTL不同。周期单位为ns，-waveform用于描述时钟形状，0ns为高电平起点，-add后不跟参数，当端口clk上声明了多个时钟时表示重复声明。</p><p>当检查外来输入信号时，其时钟没有与信号一起输入设计中，但信号时序需要检查，或者当有输出信号被片外另一个时钟采样时。这时，都需要设置虚拟时钟来代表信号的时钟。</p><p><strong>create_generated_clock</strong>: 声明内部时钟，即由端口时钟衍生的时钟例如分频时钟，-master_clock 用来说明时钟的源头，即它是由哪个端口时钟产生的。-source用来说明产生的端口。-edges用来说明新时钟相对于源时钟的形状，参数为跳变沿的编号（包括上升沿和下降沿），例如{1，3，7}表示在第一个沿变高，第3个沿变低。get_pins表明时钟产生在一个引脚上。</p><h3 id="timing-sdc"><a href="#timing-sdc" class="headerlink" title="timing.sdc"></a>timing.sdc</h3><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs tcl">creat_clock -name clk -period <span class="hljs-number">200</span> -waveform &#123;<span class="hljs-number">0</span> <span class="hljs-number">100</span>&#125; -add [get_ports &#123;clk&#125;] #声明一个从外部来的时钟，周期为<span class="hljs-number">200</span>ns，先高后低<br><span class="hljs-comment">#creat_clock -name clk -period 200 -waveform &#123;0 100&#125; #设定一个虚拟时钟，不需要指明具体的端口</span><br>creat_generated_clock -name freeclk -master_clock clk -<span class="hljs-keyword">source</span> [get_ports &#123;clk&#125;] -add -edges &#123;<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span>&#125; \<br>[get_pins&#123;u_clkCtrl/bai_freeclk_buf/Z&#125; #声明内部时钟，新产生的freeclk的源头时钟是clk, 在RTL中的端口名为clk，新时钟为源时钟<span class="hljs-number">3</span>分频，占空比为<span class="hljs-number">1</span>/<span class="hljs-number">3</span>。<br><br>set_clock_uncertainy -setup <span class="hljs-number">6</span> [get_clocks clk] #设置时钟不确定性，建立时间<br>set_clock_uncertainy -hold <span class="hljs-number">0.3</span> [get_clocks clk] #设置时钟不确定性，保持时间<br>set_clock_latency -<span class="hljs-keyword">source</span> <span class="hljs-number">0.3</span> [get_clocks clk1] #约束时钟传输时延，源延迟<br>set_clock_latency [get_clocks clk1] #约束时钟传输时延，线路延迟<br>set_clock_groups -group &#123;A B C&#125; #将时钟分为一组，存在时序关系，需要检查时序<br>set_clock_groups -asynchronous -group &#123;A B C&#125; -group &#123;D E&#125; -group &#123;F G&#125; #设定组与组之间为异步时钟，不需要时序检查<br>set_clock_groups -logically_exclusive -group &#123;B&#125; -group &#123;D&#125; -group &#123;G&#125; #设定逻辑互斥<br>set_clock_groups -physically_exclusive -group &#123;B&#125; -group &#123;D&#125; -group &#123;G&#125; #设定物理互斥<br><br>set_dont_touch [get_cell &#123;u_clkCtrl/bai_*&#125;] #阻止工具触碰元器件，防止被优化，例化的名称也不会修改<br><br>set_dont_touch_network [get_pins &#123;u_clkCtrl/bai_rst_*/Z&#125;] #阻止综合器在线路上插入元器件（例如Buffer）<br>set_ideal_network [get_pins &#123;u_clkCtrl/bai_rst*/Z&#125;] #设定为理想线路，则时序检查一定会通过<br><br>set_false_path -from u_pwm/pwm_out* -to [get ports &#123;GPIO*&#125;] #设定某一段路径避免时序检查<br><br>set_max_delay -from [get_ports GPIO*] -to[get_ports&#123;Flash_*&#125;] <span class="hljs-number">20</span>  #直接约束延迟大小（一般内部线路不使用）<br>set_input_delay -max <span class="hljs-number">3</span> -<span class="hljs-keyword">clock</span> clk [get_ports &#123;GPIO*&#125;] #约束片外延迟大小，一般不限定最小值<br>set_output_delay -max <span class="hljs-number">3</span> -<span class="hljs-keyword">clock</span> clk [get_ports &#123;GPIO*&#125;]<br><br>check_timing -include data_check_no_clock #报告没有进行约束的路径列表<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Tranquil_ovo/article/details/129904625">【DC】使用DC进行逻辑综合的基本步骤_dc更改current design-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>IC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IC DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习之极大似然估计</title>
    <link href="/2024/03/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
    <url>/2024/03/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>简单介绍机器学习中极大似然估计的原理</p><span id="more"></span><h1 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h1><p>极大似然估计(Maximum Likelihood Estimation,简称MLE)，这是根据数据采样来估计概率分布参数的经典方法。</p><p>估计类条件概率的一种常用策略是先假定其具有某种确定的概率分布形式，再基于训练样本对概率分布的参数进行估计。</p><p>极大似然估计，说的是已知某个随机样本满足某种概率分布，但是其中具体的参数并不知道，参数估计就是通过若干次实验，观察其结果，利用结果推出参数的估计值。极大似然估计的思想就是：已知某个参数使这个样本出现的概率最大，那么就将这个参数作为参数估计的真实值。</p><h2 id="样本集"><a href="#样本集" class="headerlink" title="样本集"></a>样本集</h2><p>假设这些样本是独立同分布的，记为 D，为100次抽样的结果<br>$$<br>D &#x3D; x_1, x_2, x_3,\dots, x_{100}<br>$$</p><h2 id="联合概率"><a href="#联合概率" class="headerlink" title="联合概率"></a>联合概率</h2><p>$  \theta $ 为要估计的参数，参数$ \theta $与样本$D$互相影响</p><p>则联合概率$ P(D | \theta)$称为相对于样本空间$D &#x3D; x_1, x_2, x_3,\dots, x_{100} $关于$\theta $的似然函数<br>$$<br>\begin {split} l(\theta) &amp; &#x3D; P(D | \theta) \ &amp; &#x3D; P (x_1, x_2, x_3,\dots, x_{100}| \theta) \ &amp;&#x3D;  \prod_{i&#x3D;1}^{100} P(x_i| \theta) \end{split}<br>$$</p><h2 id="极大似然函数的估计值"><a href="#极大似然函数的估计值" class="headerlink" title="极大似然函数的估计值"></a>极大似然函数的估计值</h2><p>记$ \hat{\theta} &#x3D; x_1, x_2, x_3,\dots, x_{100}$为极大似然函数的估计值<br>$$<br>\begin {split} \hat{\theta} &amp;&#x3D;  argmax_{\theta}  l(\theta) \&amp; &#x3D; argmax_{\theta} \prod_{i&#x3D;1}^{n} P(x_i|\theta)\end{split}<br>$$</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>求极大似然函数值，就是要求似然函数的导数，导数的极值点就是似然函数的最大值。</p><p>（此处要对似然函数取对数，因为连乘形式求导不方便，取对数之后变为连加形式）<br>$$<br>ln \frac{\partial l(\theta) }{ \partial \theta}  &#x3D; \sum_{i&#x3D;1}^{n} lnP(x_i | \theta)<br>$$<br>此时只需要知道联合概率函数$P$服从什么分布。</p><p>例如，在连续属性情形下，假设概率密度函数服从正态分布，即$ P(x_i|\theta) \sim N(\mu,\sigma^2) $</p><h2 id="求极大似然函数的一般步骤"><a href="#求极大似然函数的一般步骤" class="headerlink" title="求极大似然函数的一般步骤"></a>求极大似然函数的一般步骤</h2><ol><li>写出似然函数</li><li>对似然函数取对数</li><li>求导</li><li>解似然方程</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习，算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDR3基本原理</title>
    <link href="/2023/10/22/DDR3%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/10/22/DDR3%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>简单介绍DDR3的基本原理</p><span id="more"></span><h1 id="DDR3"><a href="#DDR3" class="headerlink" title="DDR3"></a>DDR3</h1><p>第三代双倍数据率同步动态随机存取存储器</p><p>（Double-Data-Rate Three Synchronous Dynamic Random Access Memory，一般称为DDR3 SDRAM）</p><p>DDR3是应用在计算机及电子产品领域的一种高带宽并行数据总线，属于SDRAM类存储器。</p><p>DDR3，在时钟信号的上升沿和下降沿均传输数据，因此相比较SDR可以达到双倍的速率。</p><h2 id="Prefrech技术："><a href="#Prefrech技术：" class="headerlink" title="Prefrech技术："></a>Prefrech技术：</h2><p>Prefetch 简单的说就是在一个<strong>内核时钟周期</strong>同时寻址多个存储单元并将这些数据以并行的方式统一传输到 IO Buffer 中，之后以更高的外传速度将 IO Buffer 中的数据传输出去。</p><p><img src="/img/article_img/DDR3/DDR3_prefrech.png"></p><p>这个寻址的单元个数称为预取数，DDR1 预取数为2，DDR2 预取数为4，DDR3预取数为8。在一个内部时钟周期内，DDR3要完成所有预取数据的向外传输。</p><p>内核时钟为DDR3芯片内部进行逻辑处理的时钟（<strong>核心频率</strong>）</p><p>还有另外一个时钟，是芯片的外部接口时钟，也就是clock管脚上的时钟频率（<strong>工作频率</strong>）</p><p>数据在由buffer传输出去时，以外部时钟参考，在时钟上升沿、下降沿传输数据，因此数据的<strong>传输速率</strong>为工作频率的两倍。</p><p><strong>三者的关系</strong>为：</p><p>传输速率 &#x3D; 工作频率 * 2；</p><p>核心频率 &#x3D; 传输频率 &#x2F; 预取数；</p><h2 id="存储地址"><a href="#存储地址" class="headerlink" title="存储地址"></a>存储地址</h2><p>DDR3内部的存储结构，可以看作是由很多层二维存储阵列组成，称为Bank。</p><p><img src="/img/article_img/DDR3/DDR3_bank.png"></p><p>DDR3内部的Bank可以看做是一个NxN的一个阵列，B代表Bank编号，C代表列地址编号，R代表行地址编号。</p><p>寻址的流程也就是先指定Bank地址，再指定行地址，然后指定列地址最终的确寻址单元。</p><p>如果寻址命令是B1、R2、C6，就能确定地址是图中红格的位置。</p><p>容量计算：Bank数量 * 行数 * 列数</p><p>例如：MT41J128M8 的数据宽度是8位，每个bank有16k的行数，1k的列数，所以寻址空间是16k*1k&#x3D;16M，每个芯片有8个bank，所以单块芯片的容量是8 * (16k1k) *8bit&#x3D;1G bit。</p><h2 id="tRCD"><a href="#tRCD" class="headerlink" title="tRCD"></a>tRCD</h2><p>在实际工作中，逻辑Bank地址与相应的行地址是同时发出的，此时这个命令称之为“行激活”（Row Active）。在此之后，将发送列地址寻址命令与具体的操作命令（是读还是写），这两个命令也是同时发出的，所以一般都会以“读&#x2F;写命令”来表示列寻址。根据相关的标准，从行有效到读&#x2F;写命令发出之间的间隔被定义为tRCD，即RAS to CAS Delay（RAS至CAS延迟，RAS就是行地址选通脉冲，CAS就是列地址选通脉冲）。</p><p>tRCD是DDR的一个重要时序参数，广义的tRCD以核心时钟周期（tCK，Clock Time）数为单位，比如tRCD&#x3D;3，就代表延迟周期为两个时钟周期，具体到确切的时间，则要根据时钟频率而定。</p><p><img src="/img/article_img/DDR3/DDR3_tRCD.png"></p><p>上图是tRCD&#x3D;3的时序图，NOP&#x3D;Not Operation，表示无操作，灰色区域表示Don’t Care。</p><h2 id="CL"><a href="#CL" class="headerlink" title="CL"></a>CL</h2><p>相关的列地址被选中以后，将会触发数据传输，但从存储单元中输出到真正出现在内存芯片的I&#x2F;O接口之间还需要一定的时间(数据触发本身就有延时，而且还需要进行信号放大)，这段时间就是列地址脉冲选通潜伏期(CAS Latency,CL)，CL的数值与tRCD一样，以时钟周期数表示。CL只针对读取操作有效。</p><h2 id="tAC"><a href="#tAC" class="headerlink" title="tAC"></a>tAC</h2><p>由于芯片体积的原因，存储单元中的电容容量很小，所以信号要经过放大来保证其有效的识别性，这个放大&#x2F;驱动工作由Sense Amplifier负责，一个存储体对应一个Sense Amplifier通道。它要有一个准备时间才能保证信号的发送强度（事前还要进行电压比较以进行逻辑电平的判断）。</p><p>从数据I&#x2F;O总线上有数据到数据输出之前的一个时钟上升沿开始，数据即已传向Sense Amplifier，也就是说此时数据已经被触发，经过一定的驱动时间最终传向数据I&#x2F;O总线进行输出，这段时间称为tAC（Access Time from CLK，时钟触发后的访问时间）。</p><p><img src="/img/article_img/DDR3/DDR3_tAC.png"></p><h2 id="突发长度"><a href="#突发长度" class="headerlink" title="突发长度"></a>突发长度</h2><p>突发（Burst）是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输的周期数就是突发长度（Burst Lengths，简称BL）。在进行突发传输时，只要指定起始列地址与突发长度，内存就会依次地自动对后面相应数量的存储单元进行读&#x2F;写操作而不再需要控制器连续地提供列地址。这样，除了第一组数据的传输需要若干个周期（主要是之前的延迟，一般的是tRCD+CL）外，其后每个数据只需一个周期的即可获得。</p><p>DDR3 的 Burst Length 一般都是 8。</p><p><img src="/img/article_img/DDR3/DDR3_BL.png"></p><h2 id="tRP"><a href="#tRP" class="headerlink" title="tRP"></a>tRP</h2><p>在数据读取完之后，为了腾出读出放大器以供同一Bank内其他行的寻址并传输数据，内存芯片将进行预充电的操作来关闭当前工作行。从开始关闭现有的工作行，到可以打开新的工作行之间的间隔就是tRP（Row Precharge command Period，行预充电有效周期），单位也是时钟周期数。</p><p>假设当前寻址的存储单元是B1、R2、C6。如果接下来的寻址命令是B1、R2、C4，则不用预充电，因为读出放大器正在为这一行服务。但如果地址命令是B1、R4、C4，由于是同一Bank的不同行，那么就必须要先把R2关闭，才能对R4寻址。</p><h2 id="数据选取脉冲（DQS）"><a href="#数据选取脉冲（DQS）" class="headerlink" title="数据选取脉冲（DQS）"></a>数据选取脉冲（DQS）</h2><p>DQS 是DDR中的重要功能，它的功能主要用来在一个时钟周期内准确的区分出每个传输周期，并便于接收方准确接收数据。每一颗芯片都有一个DQS信号线，它是双向的，在写入时它用来传送由北桥发来的DQS信号，读取时，则由芯片生成DQS向北桥发送。可以说，它就是数据的同步信号。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/liujinggang/p/9782796.html">【接口时序】8、DDR3驱动原理与FPGA实现（一、DDR的基本原理） - jgliu - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA IC DDR3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储器概述</title>
    <link href="/2023/10/22/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/22/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>存储器概述</p><span id="more"></span><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p><img src="/img/article_img/DDR3/1.png"></p><p><img src="/img/article_img/DDR3/2.png"></p><p>存储器一般来说可以分为内部存储器(内存)，外部存储器(外存)，缓冲存储器(缓存)以及闪存这几个大类。</p><p><strong>内部存储器（内存）</strong>也称为主存储器，位于系统主机板上，可以同CPU直接进行信息交换。其主要特点是：运行速度快，容量小。</p><p><strong>外部存储器（外存）</strong>也称为辅助存储器，不能与CPU之间直接进行信息交换。其主要特点是：存取速度相对内存要慢得多，存储容量大。</p><p>内存与外存本质区别是，一个是内部运行提供缓存和处理的功能，也可以理解为协同处理的通道；而外存主要是针对储存文件、图片、视频、文字等信息的载体，也可以理解为储存空间。</p><p><strong>缓冲存储器（缓存）</strong>（Cache）就是数据交换的缓冲区，当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。</p><p><strong>闪速存储器（闪存）</strong>（Flash Memory）是一种长寿命的非易失性（在断电情况下仍能保持所存储的数据信息）的存储器，数据删除不是以单个的字节为单位而是以固定的区块为单位（注意：NOR Flash 为字节存储。），区块大小一般为256KB到20MB。闪存是电子可擦除只读存储器（EEPROM）的变种，闪存与EEPROM不同的是，EEPROM能在字节水平上进行删除和重写而不是整个芯片擦写，而闪存的大部分芯片需要块擦除。由于其断电时仍能保存数据，闪存通常被用来保存设置信息，如在电脑的BIOS（基本程序）、PDA（个人数字助理）、数码相机中保存资料等。</p><h2 id="随机存储器（RAM）"><a href="#随机存储器（RAM）" class="headerlink" title="随机存储器（RAM）"></a>随机存储器（RAM）</h2><p>RAM(Random Access Memory) 随机存储器。存储单元的内容可按需随意取出或存入，且存取的速度与存储单元的位置无关的存储器。这种存储器在断电时将丢失其存储内容，故主要用于存储短时间使用的程序。 </p><p>随机存储器又分为静态随机存储器（Static RAM,SRAM)和动态随机存储器（Dynamic RAM,DRAM)。静态随机存储器SRAM（Static RAM）不需要刷新电路即能保存它内部存储的数据。</p><h3 id="动态随机存储器SDRAM"><a href="#动态随机存储器SDRAM" class="headerlink" title="动态随机存储器SDRAM"></a>动态随机存储器SDRAM</h3><p>动态随机存储器SDRAM（Synchronous DRAM）即同步动态随机存取存储器。<strong>同步</strong>是指存储器工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准；<strong>动态</strong>是指存储阵列需要不断的刷新来保证数据不丢失；<strong>随机</strong>是指数据不是线性依次存储，而是自由指定地址进行数据读写，DDR，DDR2以及DDR3就属于SDRAM的一类。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/liujinggang/p/9782796.html">【接口时序】8、DDR3驱动原理与FPGA实现（一、DDR的基本原理） - jgliu - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA IC DDR3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自适应滤波器——RLS滤波器</title>
    <link href="/2023/10/09/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E2%80%94%E2%80%94RLS%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/09/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E2%80%94%E2%80%94RLS%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>简单介绍RLS滤波器的原理</p><span id="more"></span><h1 id="RLS滤波器"><a href="#RLS滤波器" class="headerlink" title="RLS滤波器"></a>RLS滤波器</h1><h2 id="RLS自适应滤波器"><a href="#RLS自适应滤波器" class="headerlink" title="RLS自适应滤波器"></a>RLS自适应滤波器</h2><p><strong>线性方程组解的形式：</strong></p><p>具有N个方程M个未知量的线性方程组表示成矩阵形式：$ Ax &#x3D; b $ </p><p>如果$M&#x3D;N$，且矩阵A可逆，则该线性方程组为<strong>适定方程组</strong>,则可确定一个满足该方程组的唯一解：$ x &#x3D; A^{-1}b $</p><p>如果$M &lt; N$，$A$是一“高矩阵”，且设矩阵A是列满秩的，则称线性方程组为<strong>超定线性方程组</strong>。此时该线性方程组无解。可找到一个$\hat{x}$，使得估计误差向量在某种意义下取得极小值。$ e &#x3D; A\hat{x} - b $</p><p>在最小二乘（LS，Least Squares）意义下，使估计误差的模的平方和取得极小值，所得到的解称为最小二乘解，记作$ \hat{x}_{LS} $</p><p>$ \hat{x}_{LS} &#x3D; (A^TA)^{-1} A^T b $</p><p>如果$M &lt; N$，$A$是一“扁矩阵”， 且设矩阵A是行满秩的，则称线性方程组为<strong>欠定线性方程组</strong>。此时该线性方程组有无穷多个解。</p><p>在最小范数（minimum norm）意义下，可以确定唯一解$ \hat{x}_{F} &#x3D; A^T (AA^T)^{-1} b $</p><p>求解最小二乘解的方法：</p><p>定义代价函数为误差信号的模的平方和：$ J &#x3D; \sum_{n &#x3D; M}^{N} |e(n)|^2 &#x3D; e^Te$</p><p>求$J$关于$w$的梯度，$ \nabla_j  &#x3D; 0$，得到$ w &#x3D; (A^TA)^{-1} A^T b $</p><p><img src="/img/article_img/Digital_Filter/4.png"></p><p><strong>递归最小二乘算法</strong></p><p>加权最小二乘：$ \zeta(n) &#x3D; \sum_{i&#x3D;1}^{n} \lambda^{n-i}|e(i)|^2 $</p><p>考虑到输入噪声的影响，尤其是在n&#x3D;0时的影响，可采用如下正则化处理：</p><p>$ \zeta(n) &#x3D; \sum_{i&#x3D;1}^{n} \lambda^{n-i}|e(i)|^2 + \delta \lambda^n ||\hat(w(n))||^2 $</p><p>$ R_x(n) &#x3D; \sum_{i&#x3D;1}^{n} \lambda^{n-1} x(i)x(i)^H + \delta \lambda^n I $</p><p>$ r(n) &#x3D; \sum_{i&#x3D;1}^{n} \lambda^{n-1}  x(i)d^*(n) $</p><p>将自相关和互相关矩阵重新表示：</p><p>$ R_x(n) &#x3D; \lambda R_x(n-1) + x(n)x^H(n) $</p><p>$ r(n) &#x3D; \lambda r(n-1) + x(n)d^*(n) $</p><p>逆相关矩阵：$ P(n) &#x3D; R_x^{-1}(n) $</p><p>增益矢量：$ k(n) $</p><p>根据矩阵求逆引理，可以写出逆相关矩阵的递推公式：</p><p>$ P(n) &#x3D; \lambda^{-1}P(n-1) - \lambda^{-1}k(n)x^H(n)P(n-1) $</p><p>$ k(n) &#x3D; P(n)x(n) $</p><p>则权系数更新的递推公式为：</p><p>$ \hat{W(n)} &#x3D; R_x^{-1}(n) r(n) &#x3D; P(n)r(n) $</p><p>$ \hat{W(n)} &#x3D; \hat{W(n-1)} + k(n)\eta^*(n)$</p><p>其中$\eta^*(n)$为先验误差：$\eta^*(n) &#x3D; d(n) - \hat{w^H(n-1)}x(n)$</p><p>写出后验误差：$ e(n) &#x3D; d(n) - \hat{w^H(n)}x(n) $</p><p>则收敛因子为：$ \gamma(n) &#x3D; \frac{e(n)}{\eta(n)} &#x3D; 1 - k^H(n)x(n)$</p><p>当收敛因子等于1时，即先验误差等于后验误差时，滤波器的权系数达到稳定。</p><p>一般取初始条件：$ \hat{w(0)} &#x3D; 0  P(0) &#x3D; \delta^{-1}I$</p><p>参数选择：</p><p>遗忘因子$\lambda $：接近1但小于1的正常数，$0.95&lt;λ&lt;1$。$λ&#x3D;1$即平稳输入，无限记忆；输入过程的非平稳程度越严重， 则$λ$越小。 </p><p>正则化参数$δ$：$ \alpha_{\mu}^2 \mu^{\alpha} $   $ \mu &#x3D; 1- \lambda $  $\alpha_{\mu}^2  $为输入过程方差</p><p><strong>RLS算法的收敛性：</strong></p><p>RLS算法约经过$n&#x3D;2M$次迭代，即可使均方误差达到最小误差的1.5倍，而LMS算法达此水平至少需20M次迭代。 因此，RLS比LMS至少快一个数量级。 </p><p>若n趋于无限大，在不考虑量化误差的条件下，RLS算法无失调。而LMS始终存在与步长有关的失调。  </p><p>RLS算法的主要问题之一是每次迭代中的计算量与阶数M的平方成正比。虽然比之最小二乘法(M的三次方成正比) 好，但比LMS算法(M成正比)要差。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自适应滤波器——LMS滤波器</title>
    <link href="/2023/10/09/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E2%80%94%E2%80%94LMS%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/09/%E8%87%AA%E9%80%82%E5%BA%94%E6%BB%A4%E6%B3%A2%E5%99%A8%E2%80%94%E2%80%94LMS%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>简单介绍LMS滤波器的原理</p><span id="more"></span><h1 id="LMS滤波器"><a href="#LMS滤波器" class="headerlink" title="LMS滤波器"></a>LMS滤波器</h1><p><strong>自适应数字滤波器：</strong>利用前一时刻已获得的滤波器参数等结果，自动地调节现时刻的滤波器参数，以适应信号与噪声未知的或随时间变化的统计特性，从而实现最优滤波。</p><p>自适应滤波器$H(z)$的系数根据误差信号，通过一定的自适应算法，不断地进行改变，使输出$y(n)$最接近期望信号$d(n)$。</p><p>实际中，$d(n)$要根据具体情况进行选取。</p><p><img src="/img/article_img/Digital_Filter/2.png"></p><p><strong>自适应滤波器的特点：</strong>  </p><p>滤波器的参数可以自动地按照某种准则调整到最佳滤波，是一种最佳的时变数字滤波器；  </p><p>实现时不需要任何关于信号和噪声的先验统计知识；  </p><p>具有学习和跟踪的性能。</p><p><strong>自适应数字滤波器的应用</strong>  </p><p>系统模型识别；  </p><p>通信信道的自适应均衡；  </p><p>雷达与声纳的波束形成；  </p><p>消除心电图中的电源干扰；  </p><p>噪声中信号的检测、跟踪、 增强和线性预测等。</p><p><strong>自适应滤波器分类：</strong></p><p>最小均方误差（LMS）自适应滤波器</p><p>递归最小二乘（RLS）自适应滤波器</p><h2 id="LMS自适应滤波器"><a href="#LMS自适应滤波器" class="headerlink" title="LMS自适应滤波器"></a>LMS自适应滤波器</h2><p>$ y(n) &#x3D; \sum_{m&#x3D;0}^{N-1}w(m)x(n-m)$</p><p>$ y_i &#x3D; \sum_{i&#x3D;0}^{N}w_ix_{ij} $    </p><p>$ y_i &#x3D; W^T X_j $   $ W &#x3D; [w_1,w_2,\dots,w_N]^T,X_j &#x3D; [x_{1j},x_{2j},\dots,x_{Nj}]^T $</p><p>误差信号表示为：$ e_j &#x3D; d_j-y_j &#x3D; d_j - W^TX_j $</p><p>误差信号被用来作为权系数的控制信号。均方误差（性能函数）为：</p><p>$ E[e_j^2] &#x3D; E[(d_j - y_j)^2] &#x3D; E[d_j^2] - 2R_{dx}^T W + W^TR_{xx}W $</p><p>当输入信号和期望信号是平稳随机信号时，均方误差信号$ E[e_j^2] $是权系数的二次函数，它是一个中间上凹的超抛物形曲面，是具有唯一最小值的函数。</p><p><img src="/img/article_img/Digital_Filter/3.png"></p><p>调节加权系数W使均方误差最小，相当于沿超抛物形曲面下降到最小值。</p><p>在数学上，可用梯度法沿着该曲面调节权矢量的各元素得到均方误差$ E[e_j^2] $的最小值。</p><p>用$ \nabla _j $表示$ E[e_j^2] $的梯度向量，用公式表示如下：</p><p>$ \nabla _j &#x3D; [\frac{\partial E[e_j^2]}{\partial w_1}, \frac{\partial E[e_j^2]}{\partial w_2}, \dots, \frac{\partial E[e_j^2]}{\partial w_N}]^T $</p><p>$ \nabla <em>j &#x3D; 2R</em>{xx}W - 2R_{dx} &#x3D; 0 $    </p><p>最佳权矢量：$ W^* &#x3D; R_{xx}^{-1}R_{dx}  $</p><p>此时均方误差取最小值：$ E[e_j^2]<em>{min} &#x3D; E[d_j^2] - R</em>{dx}^TW^* $</p><p><strong>最陡下降法</strong></p><p>采用最优化的数学算法-最陡下降法（Steepest  Descent Method），搜索性能函数表面寻找最佳权系数。</p><p>最陡下降法的递推公式：$ W_{j+1} &#x3D; W_j + \mu(-\nabla_j) $</p><p>其中，$ \mu $是一个控制稳定性和收敛速度的参量，称之为收敛因子。$-\nabla_j $方向是性能函数下降最快的方向，因此称为最陡梯度下降法。</p><p>$E[e_{j}^2]$与$W$的关系在几何上是一个“碗形”的多维曲面。</p><p>搜索方向为梯度负方向，每一步更新都使目标函数值减小。</p><p>Widrow等人提出，采用梯度的估计值代替梯度的精确值，称为Widrow-Hoff算法。</p><p>即$  \hat{\nabla_j}&#x3D; [\frac{\partial e_j^2}{\partial w_1}, \frac{\partial e_j^2}{\partial w_2}, \dots, \frac{\partial e_j^2}{\partial w_N}]^T $</p><p>得到$  \hat{\nabla_j}&#x3D; -2e_jX_j $</p><p><img src="/img/article_img/Digital_Filter/5.png"></p><p>因此，最陡下降法的<strong>递推公式</strong>可以写成：$ W_{j+1} &#x3D; W_j + 2\mu e_jX_j $</p><p>权系数也是在理想情况下的权轨迹附近随机变化的。</p><p>搜索方向为瞬时梯度负方向，不能保证每一步更新都使目标函数值减小，但总趋势使目标函数值减小。</p><p>LMS算法的收敛条件为：$ 0 &lt; \mu &lt; \frac{1}{tr(R_{xx})} $或$ 0 &lt; \mu &lt; \frac{1}{\sum E[X_i]} $</p><p><strong>收敛性质：</strong></p><p>$\mu$值对收敛稳定性和收敛速度影响很大，首先必须选择得足够小，使之满足收敛条件，同时，它还影响收敛速度。</p><p>$\mu$偏大，收敛快，跟踪性能差，$\mu$偏小，收敛慢，跟踪性能好。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡尔曼滤波器</title>
    <link href="/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    <url>/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<p>简单介绍卡尔曼滤波器的原理</p><span id="more"></span><h1 id="卡尔曼滤波器"><a href="#卡尔曼滤波器" class="headerlink" title="卡尔曼滤波器"></a>卡尔曼滤波器</h1><h2 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h2><p>假设某系统$ n$时刻的状态变量为$x(n)$</p><p>过程方程：$ x(n+1) &#x3D; F(n+1,n)x(n) + v_1(n) $</p><p>观测方程：$ y(n) &#x3D; C(n)x(n) + v_2(n) $</p><p>$F(n+1,n)$为状态转移矩阵； $C(n)$为观测矩阵； $x(n)$为状态向量； $y(n)$为观测向量； $v_1$为过程噪声；$v_2$为观测噪声。</p><p>假设状态变量的增益矩阵F不随时间发生变化，$v_1$、$v_2$都是 零均值白噪声，方差分别是$Q_1$和$Q_2$，并且初始状态$x(0)$与$v_1$、$v_2$都不相关，且噪声向量$v_1$、$v_2$也互不相关。</p><p>Kalman滤波问题：利用观测数据$ y_1(n),y_2(n),\dots,y(n) $，对$n≥1$求状态向量$x(i)$各个分量的最小二乘估计。</p><p>kalman滤波算法的具体推导过程省略。</p><p><strong>Kalman滤波的特点：</strong></p><p>Kalman滤波采用物理意义较为直观的时间域描述方式；</p><p>采用递推算法，用前一个估计值和最近一个观察数据(它不需要全部过去的观察数据)来估计信号的当前值；</p><p>解是以估计值(常常是状态变量值)形式给出的，或者说其信号模型是从状态方程和量测方程得到的；  </p><p>适用于多维和非平稳随机信号。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维纳滤波器</title>
    <link href="/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E7%BB%B4%E7%BA%B3%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E7%BB%B4%E7%BA%B3%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>简单介绍维纳滤波器的原理</p><span id="more"></span><h1 id="维纳滤波器"><a href="#维纳滤波器" class="headerlink" title="维纳滤波器"></a>维纳滤波器</h1><h2 id="维纳滤波器-1"><a href="#维纳滤波器-1" class="headerlink" title="维纳滤波器"></a>维纳滤波器</h2><p>滤波器输出信号为：$ x(n) &#x3D; s(n) + v(n) $</p><p>滤波器输出信号为：$ y(n) &#x3D; \hat{s}(n) &#x3D;\sum_{m} h(m)x(n-m) $</p><p>误差为：$ e(n) &#x3D; s(n) - y(n) $</p><p>维纳滤波器的分析思路就是在<strong>均方误差最小</strong>的前提下，求得系统的单位脉冲响应$ h(n) $或传递函数$ H(z) $，即代价函数$ J（n） $为最小均方误差。</p><p>最小均方误差为：$ E(| e(n) |^2)_{min} $</p><p><strong>正交原理</strong>：若使滤波器的均方误差达到最小， 则误差信号与输入信号正交。</p><p>$ \nabla_k {J(n)} &#x3D; 0 $           $ E(x^*(n-k)e_{opt}(n)) &#x3D; 0 $</p><p>将误差信号使用输出信号和参考信号表示，得到<strong>维纳-霍夫方程</strong>。</p><p>$ r_{xd}(k) &#x3D; \sum_{i&#x3D;0}^{+\infty}h_{opt,i} r_{xx}(k-i) $</p><p>$r_{xd}(k)  r_{xx}(k-i) $分别为输入信号与参考信号的互相关和输入信号的自相关。</p><p><strong>FIR维纳滤波器的维纳-霍夫方程</strong>  </p><p>当$ h(n) $是一个长度为$M $的因果序列时，FIR维纳滤波器的维纳-霍夫方程表述为$ r_{xd}(k) &#x3D; \sum_{i&#x3D;0}^{M-1}h(i) r_{xx}(k-i) $</p><p>表达为矩阵形式：$ R_{xd} &#x3D; R_{xx}h $ </p><p>得到：$ h &#x3D; R_{xx}^{-1} R_{xd} $</p><p>维纳-霍夫自适应是单步算法，不需要反馈，并可用于解决以前的任何系统识别问题，逆系统辨识，噪声消除等。维纳-霍夫算法并不是实时的算法，该结构需要大量的计算。当$x(n)$和$s(n) $的统计特性发生变化，就需要重新计算滤波器，此时算法将失去跟踪功能。因此，在实时数学信号处理中，直接使用维纳-霍夫算法是不可行的。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匹配滤波器</title>
    <link href="/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%8C%B9%E9%85%8D%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/10/09/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E2%80%94%E2%80%94%E5%8C%B9%E9%85%8D%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>简单介绍匹配滤波器的原理</p><span id="more"></span><h1 id="匹配滤波器"><a href="#匹配滤波器" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h1><p>信号处理的目的是从噪声中提取信号，得到不受干扰影响的真正信号。采用的处理系统称为滤波器。 </p><p>实时信号处理中，希望滤波器的参数可以根据系统或环境的变化进行更新，称为自适应滤波器。</p><p><strong>最优滤波</strong></p><p>所谓最优是在某种标准下系统性能达到最佳。  </p><p>相对性：在某种准则下的最优系统，在另外一种准则下就不一定是最优的。  </p><p>等价性：在某些特定条件下，几种最优准则也可能是等价的。  </p><p><strong>最优线性滤波器的设计准则：</strong>  </p><p>滤波器输出<strong>信噪比</strong>在某一特定时刻达到最大，称为<strong>匹配滤波器</strong>；  </p><p>滤波器输出的信号波形与发送信号波形之间的<strong>均方误差</strong>最小，称为<strong>维纳滤波器</strong>。</p><h2 id="匹配滤波器-1"><a href="#匹配滤波器-1" class="headerlink" title="匹配滤波器"></a>匹配滤波器</h2><p>滤波器输入：$ r(t) &#x3D; s(t) + n(t) $</p><p>滤波器输出：$ y(t) &#x3D; s_0(t) + n_0(t) $</p><p><img src="/img/article_img/Digital_Filter/1.png"></p><p>在抽样时刻$ t_0 $，滤波器输出信号的瞬时功率与噪声平均功率之比达到最大时，匹配滤波器的单位冲激响应为：(假设$ n(t) $为零均值和单位方差的白噪声，其功率谱为1)</p><p>$ h(t) &#x3D; s(t_0 - t) $</p><p>即匹配滤波器的单位冲激响应$ h(t) $是输入信号$ s(t) $的镜像函数，$t_0 $时刻输出信噪比最大。（$ t_0 &gt;&#x3D; T_0 $）</p><p>输出信号：$ s_0(t) &#x3D; s(t) * h(t) &#x3D; \int_{-\infty}^{-\infty} s(t - \tau)h(\tau) d\tau &#x3D; \int_{-\infty}^{-\infty} s(t - \tau)s(t_0 - \tau ) d\tau $ </p><p>匹配滤波器的输出波形是输入信号$ s(t) $的自相关函数。因此，匹配滤波器可以看成是一个计算输入信号自相关函数的相关器，其在$t_0$时刻得到最大输出信噪比。</p><p><strong>实际应用</strong></p><p><strong>应用1：包含噪声的通信信号检测。</strong></p><p>基站接收到通信信号，信号叠加了一定的噪声，通过对信号进行匹配滤波，在时域上，如果滤波器输出信号包含明显的峰值，即在某一时刻的信噪比最大，信号中包含了有用信号。在频域上，观察经过滤波器之后的信号频率分量即为有用信号的频率分量。否则，接收到的信号为无用信号。</p><p><strong>应用2：雷达探测目标</strong></p><p>雷达发送信号，并接受反射到的信号。反射信号叠加了一定的噪声，对信号进行匹配滤波。观察滤波器的输出信号，是否有明显的峰值，例如，匹配滤波后的信号有三个明显峰值，经过目标判决器（即峰值比较），判定有三个目标，并可以根据峰值的时刻确定目标的相对距离。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理之数字滤波器</title>
    <link href="/2023/08/22/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2023/08/22/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E6%95%B0%E5%AD%97%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>简单介绍FIR滤波器和IIR滤波器的原理和结构</p><span id="more"></span><h1 id="数字信号处理之数字滤波器"><a href="#数字信号处理之数字滤波器" class="headerlink" title="数字信号处理之数字滤波器"></a>数字信号处理之数字滤波器</h1><p>数字滤波器一般可以分为以下几类：</p><p>（1）有限冲激响应滤波器（FIR），也称为非递归线性滤波器，这种类型的滤波器没有反馈通道。</p><p>（2）无限冲激响应滤波器（IIR），也称为递归线性滤波器，这种类型的滤波器带有反馈通道。</p><p>（3）自适应数字滤波器（ADF），这种滤波器能够将自身适应为预期信号，且具有自主学习能力。</p><p>（4）非线性滤波器，一种可以执行非线性操作的滤波器。典型地，中值滤波器和最小&#x2F;最大滤波器就属于非线性滤波器。</p><h2 id="FIR滤波器"><a href="#FIR滤波器" class="headerlink" title="FIR滤波器"></a>FIR滤波器</h2><p>FIR滤波器是对N个采样数据执行加权和平均（卷积）的处理。<br>$$<br>y(k) &#x3D; \sum_{n&#x3D;0}^{N-1}W_nx(k-n)<br>$$<br>对上式取z变换，得到<br>$$<br>\frac{Y(z)}{X(z)} &#x3D; \sum_{k&#x3D;0}^{N-1}W_n z^{-k}<br>$$<br>具有3个权值（或抽头）滤波器的差分方程表示为<br>$$<br>y(k) &#x3D; W_0x(k) + W_1x(k-1) + W_2x(k-2)<br>$$</p><p>三抽头滤波器的结构如图所示：暂略</p><p>需要适当的选择从$ W_0$到$W_{N-1}$的系数，以保证滤波器能达到设计的性能要求。</p><h2 id="IIR滤波器"><a href="#IIR滤波器" class="headerlink" title="IIR滤波器"></a>IIR滤波器</h2><p>IIR滤波器既包含递归部分也包含非递归部分。</p><p>一个IIR滤波器可看成是由两个FIR滤波器构成的，其中一个滤波器位于反馈回路中。</p><p>IIR滤波器不具有线性相位，故而存在相位失真。IIR滤波器的设计是基于双线性变换法，这种方法是通过s域中的模拟滤波器的设计原型，得到一个近似的离散模型。</p><p>对于一个具有N个前馈系数和M-1个反馈系数的IIR滤波器，其输入和输出关系表示为<br>$$<br>y(k) &#x3D; \sum_{n&#x3D;0}^{N-1}a_n x(k-n) + \sum_{m&#x3D;1}^{M-1} b_m y(k-m)<br>$$</p><p>这里没有滤波器系数$ b_0 $，否则，将存在一个无延迟单元的反馈之路，滤波器将变得不可实现。滤波器不需要具有相同的系数个数。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理之傅里叶变换</title>
    <link href="/2023/08/10/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <url>/2023/08/10/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B9%8B%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>简单介绍离散傅里叶变换与其快速算法的原理</p><span id="more"></span><h1 id="数字信号处理之傅里叶变换"><a href="#数字信号处理之傅里叶变换" class="headerlink" title="数字信号处理之傅里叶变换"></a>数字信号处理之傅里叶变换</h1><p>有限长序列在数字信号处理中是很重要的一种序列，研究有限长序列的一种有用的工具是离散傅里叶变换（DFT）。</p><p>离散傅里叶变换是有限长序列的一种傅里叶表示法，在理论上十分重要。而且存在计算离散傅里叶变换的有效快速算法，即快速傅里叶变换（FFT）。</p><h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>离散傅里叶变换在时域和频域都是离散的，DFT的变换对为：<br>$$<br>X(k) &#x3D; \sum_{n&#x3D;0}^{N-1} x(n)W_N^{nk} \qquad k&#x3D;0,1,2,\cdots,N-1<br>$$</p><p>$$<br>x(n) &#x3D; \frac{1}{N} \sum_{k&#x3D;0}^{N-1}X(k)W_N^{-nk}  \qquad n&#x3D;0,1,2,\cdots,N-1<br>$$</p><p>其中<br>$$<br>W_N &#x3D; e^{-j \frac{2\pi}{N}}<br>$$<br>时域抽样间隔为T时，频域周期$ \Omega_s &#x3D; 2\pi&#x2F;T $，时域周期为$ T_1 $时，频域抽样间隔为$ \Omega_1 &#x3D; 2\pi &#x2F; T_1 $。</p><h3 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h3><p>序列x(n)的n点DFT是x(n)的z变换在单位圆上的N点等间隔采样。是x(n)的傅里叶变换在区间$ [0,2\pi] $上的N点等间隔采样。</p><h3 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h3><p>时域采样定理：当采样频率大于等于信号中最大频率分量的2倍时，可以由时域采样信号恢复原来的连续信号。</p><p>频域采样定理：当采样点数N大于等于序列长度M时，可以由频域采样X(k)来表示X(z)，否则会发生混叠现象。</p><h3 id="谱分析存在的问题"><a href="#谱分析存在的问题" class="headerlink" title="谱分析存在的问题"></a>谱分析存在的问题</h3><p>1.栅栏效应</p><p>只能看见N个离散采样点的谱特性，看不到全部的频谱特性，由于栅栏效应，有可能漏掉大的频谱分量。可以采用在原序列尾部补零的方法，改变序列长度N（即该百年DFT变换区间长度），从而增加频域采样点数和采样点为止，使原来漏掉的某些频谱分量被检测出来。</p><p>2.频率相应的混叠失真及参数选择</p><p>根据时域抽样定理，抽样频率$ f_s &gt;2f_c $，否则会产生频率响应的混叠失真。对于DFT来说，抽样间隔为F，时域周期为$ T_p &#x3D; 1&#x2F;F $，F为频率分辨率，F越小，谱分析的结果就越接近原连续信号的频谱。</p><p>当N保持不变，要提高谱的分辨率，必须降低$ f_s  $，但是受到时域采样定理的限制；当$ f_s $保持不变，为提高频率分辨率可以增加采样点数N。</p><p>3.截断效应</p><p>在持续时间无限长的信号中截取有限长个数据，就相当于在时域乘一个矩形窗函数，窗内的数据并不改变。时域中相乘，频域中相当于卷积，卷积的结果和原来的频谱不相同，有失真。这种失真最主要的是造成频谱的”扩散“，也就是所谓的”频谱泄漏“。并且泄露也会造成混叠。</p><p>减小泄漏的方法，一方面是取更长的数据，也就是窗宽加宽；另一方面是数据不要突然截断，要缓慢截断，也就是不加矩形窗，而是加如三角形窗、升余弦窗等，使得窗谱的旁瓣能量更小，卷积后造成的泄漏减小。</p><h2 id="快速傅里叶变换FFT"><a href="#快速傅里叶变换FFT" class="headerlink" title="快速傅里叶变换FFT"></a>快速傅里叶变换FFT</h2><p>直接按照离散傅里叶变换的定义计算N点DFT时，总计算量需要$ N(N-1) $次复数加法和$ N^2 $次复数乘法。</p><h3 id="按时间抽取的基-2FFT算法"><a href="#按时间抽取的基-2FFT算法" class="headerlink" title="按时间抽取的基-2FFT算法"></a>按时间抽取的基-2FFT算法</h3><p>将原序列按n的奇偶分为两组，通过不断将N点DFT分解为N&#x2F;2点DFT，最后分解为最简单的2点DFT。</p><h3 id="按频率抽取的基-2FFT算法"><a href="#按频率抽取的基-2FFT算法" class="headerlink" title="按频率抽取的基-2FFT算法"></a>按频率抽取的基-2FFT算法</h3><p>将原序列写成前后两部分，通过不断将N点DFT分解为N&#x2F;2点DFT，最后分解为最简单的2点DFT。</p><p>两种算的计算量完全相同，具体计算原理和过程有所区别，这里省略详细的推导过程。</p><h3 id="计算量分析"><a href="#计算量分析" class="headerlink" title="计算量分析"></a>计算量分析</h3><p>对于N点DFT，</p><p>$ \log_2 N $级蝶形运算，每一级都由$ N&#x2F;2 $个蝶形运算构成。</p><p>复数乘法：$ \frac{N}{2} \log_2N $</p><p>复数加法：$ N\log_2 N $</p><p>DFT与FFT计算量对比</p><table><thead><tr><th></th><th>DFT</th><th>FFT</th></tr></thead><tbody><tr><td>复数乘法</td><td>$ N^2 $</td><td>$ \frac{N}{2} \log_2N $</td></tr><tr><td>复数加法</td><td>$ N(N-1) $</td><td>$ N\log_2 N $</td></tr></tbody></table><h3 id="混合基FFT算法"><a href="#混合基FFT算法" class="headerlink" title="混合基FFT算法"></a>混合基FFT算法</h3><p>基-2FFT算法，需要满足$ N &#x3D; 2^L $的条件，因为需要经过多次分解，将N点DFT分解为多个2点DFT。</p><p>当N不满足这个条件时，一般有一下方法：</p><p>一方面，将序列x(n)使用补零的方法延长，使N增长到最近的$ N &#x3D; 2^L $的数值。因为有限长序列补零后并不影响其频谱，只是增加频谱的采样点数。因此，如果只是为了了解整个频谱而不是特定频率点，则可以使用这种方法。</p><p>另一方面，如果要求特定频率点的频谱，则N不能改变，可以使用以任意数为基数的FFT算法。</p>]]></content>
    
    
    <categories>
      
      <category>DSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microblze软核的应用（自定义IP_PWM）</title>
    <link href="/2023/07/19/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89IP_PWM%EF%BC%89/"/>
    <url>/2023/07/19/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89IP_PWM%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>介绍自定义IP核，并使用Microblaze软核控制。</p><span id="more"></span><h1 id="Microblaze软核的应用（自定义IP-PWM）"><a href="#Microblaze软核的应用（自定义IP-PWM）" class="headerlink" title="Microblaze软核的应用（自定义IP_PWM）"></a>Microblaze软核的应用（自定义IP_PWM）</h1><p>前面介绍了Microblaze软核的开发流程，如何建立一个Microblaze系统，添加IP核，完成基本的操作。</p><p><a href="https://vinters-v.github.io/2023/07/09/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88GPIO&UART%EF%BC%89/">Microblze软核的应用（GPIO&amp;UART） - Vinters-v</a></p><p>但是，在实际应用中，Vivado提供的IP核不足以满足设计的要求。因此，我们常常需要自己设计相应的逻辑电路，封装成IP核，添加到系统中，并使用Microblaze软核对其进行控制，完成一定的功能。</p><p>这里以PWM波产生为例，如果使用CPU产生PWM波的话，需要使用定时器资源，然而在单片机中定时器资源有限。而使用FPGA或者说设计数字电路实现PWM是非常简单的。而对于PWM波的周期和占空比的控制，FPGA则不擅长。</p><p>因此，本文在FPGA器件上设计一个用于PWM波产生的数字电路模块，将其封装成IP核。设计Microblaze系统，添加PWM波产生IP，完成软件控制PWM波周期与占空比的功能。</p><h2 id="1-PWM波产生IP核设计与封装"><a href="#1-PWM波产生IP核设计与封装" class="headerlink" title="1.PWM波产生IP核设计与封装"></a>1.PWM波产生IP核设计与封装</h2><h3 id="PWM波逻辑程序"><a href="#PWM波逻辑程序" class="headerlink" title="PWM波逻辑程序"></a>PWM波逻辑程序</h3><p>Verilog编写pwm波的原理，设计一个同步二进制加法计数器，当计数器的时钟频率固定时，计数器的模值，或者说溢出值就决定了pwm波的周期。只需要根据占空比计算在一个计数周期内pwm波输出端口的高电平的时间。</p><p>模块设置两个输入参数，一个为计数器模值，一个为根据占空比计算的高电平计数长度。在一个周期内，输出端口首先输出高电平，当计数器的计数值大于设置高电平长度时，输出端口输出低电平。pwm波产生的Verilog程序如下。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> PWM(clk,reset,period,duty,pwm_out);<br>    <br><span class="hljs-keyword">parameter</span> N = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">input</span> clk;<br><span class="hljs-keyword">input</span> reset;<br><span class="hljs-keyword">input</span> [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] period;   <span class="hljs-comment">//计数器模值</span><br><span class="hljs-keyword">input</span> [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] duty;     <span class="hljs-comment">//高电平长度</span><br><span class="hljs-keyword">output</span> pwm_out;<br><br><span class="hljs-keyword">reg</span> [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] cnt;<br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> reset)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(!reset) cnt &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt &lt; period-<span class="hljs-number">1</span>) cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span>;<br>    <span class="hljs-keyword">else</span> cnt &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">end</span><br>    <br><br><span class="hljs-keyword">assign</span> pwm_out = (cnt &lt; duty) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="仿真验证硬件正确性"><a href="#仿真验证硬件正确性" class="headerlink" title="仿真验证硬件正确性"></a>仿真验证硬件正确性</h3><p>编程仿真程序，测试模块设计是否符合要求。只需要在仿真文件中例化PWM模块，初始化给定两个参数值，并设置时钟输入即可。这里不进行详细介绍。</p><h3 id="封装IP"><a href="#封装IP" class="headerlink" title="封装IP"></a>封装IP</h3><p>程序编写好，并通过仿真之后，就可以将写好的PWM模块封装成IP。步骤如下：</p><p>在Vivado软件上方工具栏，选择Tools-&gt;Create and Package New IP，因为IP要在BD设计中使用，因此，将IP封装为AXI4总线格式，在弹窗中选择Create a new AXI4 peripheral。</p><p><img src="/img/article_img/Microblaze_PWM/1.png"></p><p>接着设置模块的名称，模块是作为主设备还是从设备，模块寄存器个数等等。</p><p><img src="/img/article_img/Microblaze_PWM/2.png"></p><p><img src="/img/article_img/Microblaze_PWM/3.png"></p><p><img src="/img/article_img/Microblaze_PWM/4.png"></p><p>生成IP之后，就可以在IP catalog的用户自定义IP中找到PWM IP核。但此时的IP核中还没有实际的功能，需要添加已经写好的PWM成雪到IP核中。</p><p>首先找到PWM IP核，右键选择Edit  in IP Packager，此时Vivado软件会打开另一个工程文件，用于修改PWM IP的内容。</p><p><img src="/img/article_img/Microblaze_PWM/5.png"></p><p>在新的工程文件中，已经有一个设计文件，我们需要将之前写好的PWM程序添加到设计文件中，然后在PWM IP设计文件的底层程序中例化PWM模块。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Add user logic here</span><br>PWM pwm_init_0(<br>    <span class="hljs-variable">.clk</span>(S_AXI_ACLK),<br>    <span class="hljs-variable">.reset</span>(S_AXI_ARESETN),<br>    <span class="hljs-variable">.period</span>(slv_reg0),<br>    <span class="hljs-variable">.duty</span>(slv_reg1),<br>    <span class="hljs-variable">.pwm_out</span>(pwm_0)<br>    );<br>    <br>PWM pwm_init_1(<br>    <span class="hljs-variable">.clk</span>(S_AXI_ACLK),<br>    <span class="hljs-variable">.reset</span>(S_AXI_ARESETN),<br>    <span class="hljs-variable">.period</span>(slv_reg2),<br>    <span class="hljs-variable">.duty</span>(slv_reg3),<br>    <span class="hljs-variable">.pwm_out</span>(pwm_1)<br>    );<br><span class="hljs-comment">// User logic ends</span><br></code></pre></td></tr></table></figure><p>其中时钟和复位信号以及两个寄存器，在原有文件中已有定义，pwm输出端口需要我们自行定义。</p><p>在底层文件的用户端口定义区域添加代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Users to add ports here</span><br><span class="hljs-keyword">output</span> pwm_0,<br><span class="hljs-keyword">output</span> pwm_1,<br><br><span class="hljs-comment">// User ports ends</span><br></code></pre></td></tr></table></figure><p>同时在顶层文件中的端口定义区域添加输出端口定义，并在例化下层模块处，添加输出端口例化。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-variable">.pwm_0</span>(pwm_0),<br><span class="hljs-variable">.pwm_1</span>(pwm_1),<br></code></pre></td></tr></table></figure><p>例化后的文件结构如下</p><p><img src="/img/article_img/Microblaze_PWM/6.png"></p><p>修改完成后，打开文件component.xml，将Packaging Steps下的所有步骤更新并重新生成IP。</p><p><img src="/img/article_img/Microblaze_PWM/7.png"></p><p>重新生成后，新的工程文件会自动关闭，跳回到之前设计PWM的HDL的工程文件中，此时PWM IP核的封装就已经完成了，可以将之前编写的PWM的Verilog程序从工程中删除。</p><h2 id="2-添加Microblaze系统"><a href="#2-添加Microblaze系统" class="headerlink" title="2. 添加Microblaze系统"></a>2. 添加Microblaze系统</h2><p>创建Block Design，添加时钟产生模块，Microblaze处理器模块，PWM模块，添加处理器周围模块，自动布线等等。</p><p>具体的设计流程与上一篇文章类似，这里不再详细介绍。</p><p><a href="https://vinters-v.github.io/2023/07/09/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88GPIO&UART%EF%BC%89/">Microblze软核的应用（GPIO&amp;UART） - Vinters-v</a></p><p>完成综合、实现、比特流生成之后，硬件设计就算完成了，最后导出硬件设计文件，连接到SDK，进行软件的开发。</p><h2 id="3-SDK软件开发"><a href="#3-SDK软件开发" class="headerlink" title="3. SDK软件开发"></a>3. SDK软件开发</h2><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>由于本次工程的pwm ip模块是自定义的，所以生成硬件设计文件后，SDK并不会自动生成相应的模板供我们参考使用。因此，这里直接使用hello world模板建立工程即可。</p><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;platform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xil_printf.h&quot;</span></span><br><span class="hljs-comment">//需要自行添加</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xparameters.h&quot;</span> <span class="hljs-comment">//包含了各种硬件的参数定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm_ip.h&quot;</span>  <span class="hljs-comment">//pwm模块相关的配置函数与寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xil_io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sleep.h&quot;</span></span><br></code></pre></td></tr></table></figure><p>hello world模板中已经添加了几个必要的头文件，为了能够使用pwm模块，还必须自行添加几个头文件。首先pwm_ip.h文件中，包含了pwm模块的各种配置函数的定义，以及寄存器的定义。xparameters.h文件包含了系统所有硬件的参数定义，对于pwm模块来说，需要的有模块的基地址，设备ID等等。由于使用到了usleep函数，因此需要包含sleep.h文件。</p><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>程序设计与其他单片机的设计类似，这里pwm模块的使用主要涉及到寄存器的读写，包括对寄存器写入频率控制变量和占空比控制变量。这里实现了频率固定，占空比循环变化的pwm波。程序如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;platform.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xil_printf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xparameters.h&quot;</span> <span class="hljs-comment">//包含了各种硬件的参数定义</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pwm_ip.h&quot;</span>  <span class="hljs-comment">//pwm模块相关的配置函数与寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;xil_io.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sleep.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    init_platform();<br><br>    print(<span class="hljs-string">&quot;Hello World\n\r&quot;</span>);<br>    u32 period;<br>    u32 duty;<br>    period = <span class="hljs-number">1000000</span>;<span class="hljs-comment">//实际频率为100MHZ/period</span><br><br>    <span class="hljs-comment">//对pwm中的寄存器进行配置（其中reg0和reg2分别是两个频率寄存器，reg1和reg3是两个占空比寄存器）</span><br>    PWM_IP_mWriteReg(XPAR_PWM_IP_0_S00_AXI_BASEADDR, PWM_IP_S00_AXI_SLV_REG0_OFFSET, period);<br>    PWM_IP_mWriteReg(XPAR_PWM_IP_0_S00_AXI_BASEADDR, PWM_IP_S00_AXI_SLV_REG2_OFFSET, period);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>    <span class="hljs-keyword">for</span>(duty = period; duty &gt; <span class="hljs-number">0</span>; duty = duty - <span class="hljs-number">100000</span>)<br>    &#123;<br>        PWM_IP_mWriteReg(XPAR_PWM_IP_0_S00_AXI_BASEADDR, PWM_IP_S00_AXI_SLV_REG1_OFFSET, duty);<br>        PWM_IP_mWriteReg(XPAR_PWM_IP_0_S00_AXI_BASEADDR, PWM_IP_S00_AXI_SLV_REG3_OFFSET, period - duty);<br>        usleep(<span class="hljs-number">100000</span>);<span class="hljs-comment">//将线程挂起</span><br>    &#125;<br>    &#125;<br><br>    cleanup_platform();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="烧写与验证"><a href="#烧写与验证" class="headerlink" title="烧写与验证"></a>烧写与验证</h3><p>程序设计完成之后，就可以对FPGA器件进行烧写。首先点击工具栏中的“Program FPGA”，将硬件设计烧写到FPGA上，然后，选择Run As-&gt;Launch on Hardware(System Debugger)将软件代码下载到CPU中，观察板子上LED灯的变化，符合设计要求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的主要目的是以pwm产生为例，展示如何自己使用Verilog设计模块，封装为IP核，并由Microblaze控制其完成功能这一整套流程。初步学习了“PS+PL”的系统设计。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>Verilog</tag>
      
      <tag>Microblaze</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microblze软核的应用（GPIO&amp;UART）</title>
    <link href="/2023/07/09/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88GPIO&amp;UART%EF%BC%89/"/>
    <url>/2023/07/09/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88GPIO&amp;UART%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>介绍Microblaze软核开发的具体流程，以GPIO与UART外设为例。</p><span id="more"></span><h1 id="Microblaze软核的应用（GPIO-amp-UART）"><a href="#Microblaze软核的应用（GPIO-amp-UART）" class="headerlink" title="Microblaze软核的应用（GPIO&amp;UART）"></a>Microblaze软核的应用（GPIO&amp;UART）</h1><p>使用Vivado软件部署Microblaze软核，并添加GPIO外设与URAT外设，完成整个流程的设计与验证。</p><p>首先新建一个新的RTL工程，选择合适的FPGA器件，这里选择 ，不添加任何的设计文件。</p><h2 id="1-添加Microblaze软处理器核"><a href="#1-添加Microblaze软处理器核" class="headerlink" title="1.添加Microblaze软处理器核"></a>1.添加Microblaze软处理器核</h2><p>在Vivado软件界面，在左侧功能栏中，选择Create Block Design,新建一个BD设计文件。点击“+”，向BD设计中添加IP核，选择Microblaze，将软处理器核添加到设计。</p><p><img src="/img/article_img/Microblaze_GPIO/1.png"></p><h2 id="2-配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。"><a href="#2-配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。" class="headerlink" title="2.配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。"></a>2.配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。</h2><p>添加时钟产生模块Clocking Wizard,根据开发板的手册选择输入时钟的频率，输入时钟的频率要与开发板外部时钟源频率一致。模块的复位端口reset默认为高电平有效，一般修改为低电平有效，根据设计需要设置输出时钟的个数和频率大小。</p><p><img src="/img/article_img/Microblaze_GPIO/2.png"></p><p>时钟模块添加后，点击BD设计文件上方的Run Block Automain，软件自动生成处理器必须的外围电路模块，并完成一部分连线。</p><h2 id="3-添加设计所需要的IP核"><a href="#3-添加设计所需要的IP核" class="headerlink" title="3.添加设计所需要的IP核"></a>3.添加设计所需要的IP核</h2><p>添加AXI GPIO模块，同一种用途的IO可以添加一组GPIO，例如，用于LED的IO添加一组GPIO_0，用于按钮开关的添加一组GPIO_1。设置每一组GPIO的输出位数，也就是IO个数。还有数据的输入输出方向。需要用到中断时，则可以是能中断。</p><p><img src="/img/article_img/Microblaze_GPIO/3.png"></p><p>添加AXI Uartlite模块，一般只需要设置波特率即可。</p><p><img src="/img/article_img/Microblaze_GPIO/4.png"></p><p>所有IP核添加完成后，点击BD设计文件上方的Run Connection Automation进行模块之间的自动连接。</p><p>设计完成后点击Validate Design按钮对设计进行检查，没有error即可。</p><h2 id="4-进行管脚约束"><a href="#4-进行管脚约束" class="headerlink" title="4. 进行管脚约束"></a>4. 进行管脚约束</h2><p>对系统中的时钟，复位，以及需要的其他外设的接口进行管脚约束文件的编写，一般直接在Constrains文件中新建约束文件编写代码即可。</p><h2 id="5-完成硬件设计，导出硬件设计文件"><a href="#5-完成硬件设计，导出硬件设计文件" class="headerlink" title="5.完成硬件设计，导出硬件设计文件"></a>5.完成硬件设计，导出硬件设计文件</h2><p>与FPGA中逻辑设计的步骤相同，对硬件设计依次进行综合、实现、比特流文件生成。则完成了硬件电路的设计。</p><p>选择File-&gt;Export-&gt;Export Hardware，导入硬件设计文件，勾选include bitstream。</p><p><img src="/img/article_img/Microblaze_GPIO/5.png"></p><h2 id="6-进行SDK软件开发"><a href="#6-进行SDK软件开发" class="headerlink" title="6.进行SDK软件开发"></a>6.进行SDK软件开发</h2><p>选择File-&gt;Launch SDK，连接到SDK软件，软件会自动添加好刚刚设计好并导出的硬件信息。</p><p>在进行SDK软件开发时，有两种方法。</p><p>一是，选择File-&gt;New-&gt;Application Project，新建一个新的应用工程，采用hello world模板，这个模板是包含了最简单的代码结构。对于自己设计封装的IP核，只能采用这种方式。</p><p>二是，进入system.mss文件，这个文件包含了硬件所支持的开发包，对于每一个添加系统中的IP核，如GPIO，UART等等，都会有一个说明文件Documention与例程文件。对于Vivado中自带的IP核，可以直接导入例程文件Import Examples，在此基础上进行软件开发。</p><p><img src="/img/article_img/Microblaze_GPIO/6.png"></p><h2 id="7-下载硬件设计到FPGA，调试软件代码"><a href="#7-下载硬件设计到FPGA，调试软件代码" class="headerlink" title="7.下载硬件设计到FPGA，调试软件代码"></a>7.下载硬件设计到FPGA，调试软件代码</h2><p>完成软件设计后，连接FPGA，首先点击Program FPGA，将硬件设计下载到FPGA中。然后在应用工程总的文件夹上右键，选择Run As-&gt;Launch on Hardware(System Debugger)将软件代码下载到CPU中，进行软件代码的调试。</p>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>Verilog</tag>
      
      <tag>Microblaze</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Microblze软核的概述</title>
    <link href="/2023/07/08/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/07/08/Microblaze%E8%BD%AF%E6%A0%B8%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>对Microblaze软核作简单概述，列举软核开发流程</p><span id="more"></span><h1 id="Microblaze软核的概述"><a href="#Microblaze软核的概述" class="headerlink" title="Microblaze软核的概述"></a>Microblaze软核的概述</h1><p>FPGA(Field Programmable Gate Array)即现场可编程门列，属于可编程逻辑器件的一种。是当今实现数字系统的主流平台之一。</p><p>FPGA具有硬件可编程的特点，它的内部有大量的逻辑门组成，可以通过编程实现基本电路的之间的连接，从而构成各种数字电路模块，进而设计复杂的数字系统。</p><p>然而，FPGA在设计数字电路上具有优势，对于需要进行控制，或者需要程序串行运行的场合就显得笨拙。对此，通过在FPGA器件内部部署软处理器核来解决这个问题。这里介绍Microblaze软处理器核。</p><p>软处理器核简称“软核”，即处理器并不是固定在FPGA器件内部的 ，当需要使用处理器进行设计时，则使用FPGA的逻辑资源例化一个Microblaze软核，这样FPGA内部就有了一个CPU和其他可以自由配置的逻辑资源，CPU与逻辑电路在FPGA内部连接，使设计更加方便灵活。</p><p>MicroBlaze™ CPU 是嵌入式、可修改预置 32 位 &#x2F; 64 位 RISC 微处理器配置系列。系统设计者可在没有任何 FPGA 经验的情况下，利用 2019.2 中的 Vitis™ Core 开发套件或使用 2019.1 或更早版本中基于 Eclipse 的 Xilinx 软件开发套件 (SDK)，进行MicroBlaze 处理器的开发。</p><p>这里采用的Vivado版本为2081.3，使用SDK进行Microblaze软核的开发。</p><p>开发的流程如下：</p><h2 id="1-添加Microblaze软处理器核"><a href="#1-添加Microblaze软处理器核" class="headerlink" title="1.添加Microblaze软处理器核"></a>1.添加Microblaze软处理器核</h2><h2 id="2-配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。"><a href="#2-配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。" class="headerlink" title="2.配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。"></a>2.配置处理器必需的硬件如时钟产生模块，复位模块，存储器模块等。</h2><h2 id="3-添加设计所需要的IP核"><a href="#3-添加设计所需要的IP核" class="headerlink" title="3.添加设计所需要的IP核"></a>3.添加设计所需要的IP核</h2><p>Vivado提供了众多的IP核用于嵌入式开发，如GPIO控制器、串口UART、中断控制器、块RAM接口控制器、中央DMA控制器、ADC\DAC、IIC总线接口等等。</p><p>此外，对于自己设计的逻辑电路也可以配置为IP核，与Microblaze软处理器连接，实现处理器对电路的控制。</p><h2 id="4-进行管脚约束"><a href="#4-进行管脚约束" class="headerlink" title="4. 进行管脚约束"></a>4. 进行管脚约束</h2><h2 id="5-完成硬件设计，导出硬件设计文件"><a href="#5-完成硬件设计，导出硬件设计文件" class="headerlink" title="5.完成硬件设计，导出硬件设计文件"></a>5.完成硬件设计，导出硬件设计文件</h2><h2 id="6-进行SDK软件开发"><a href="#6-进行SDK软件开发" class="headerlink" title="6.进行SDK软件开发"></a>6.进行SDK软件开发</h2><h2 id="7-下载硬件设计到FPGA，调试软件代码"><a href="#7-下载硬件设计到FPGA，调试软件代码" class="headerlink" title="7.下载硬件设计到FPGA，调试软件代码"></a>7.下载硬件设计到FPGA，调试软件代码</h2>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>Verilog</tag>
      
      <tag>Microblaze</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FPGA常用基础模块</title>
    <link href="/2023/07/03/FPGA%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/"/>
    <url>/2023/07/03/FPGA%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>数字电路中常用基础模块</p><span id="more"></span><h1 id="FPGA常用基础模块"><a href="#FPGA常用基础模块" class="headerlink" title="FPGA常用基础模块"></a>FPGA常用基础模块</h1><p>列举一些比较典型的数字电路，包括组合逻辑电路和时序逻辑电路。体现一定的Verilog语法与编程技巧。同时这些模块也是作为实际电路设计中比较通用的模块。</p><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><h3 id="1-8-1数据选择器"><a href="#1-8-1数据选择器" class="headerlink" title="1.  8-1数据选择器"></a>1.  8-1数据选择器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> choose(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] A, <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] D,<br>    <span class="hljs-keyword">output</span> Y<br>    );<br><span class="hljs-keyword">reg</span> y_temp;<br><span class="hljs-keyword">always</span> @(A <span class="hljs-keyword">or</span> D)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">case</span>(A)<br><span class="hljs-number">3&#x27;b000</span>: y_temp = D[<span class="hljs-number">0</span>];<br><span class="hljs-number">3&#x27;b001</span>: y_temp = D[<span class="hljs-number">1</span>];<br><span class="hljs-number">3&#x27;b010</span>: y_temp = D[<span class="hljs-number">2</span>];<br><span class="hljs-number">3&#x27;b011</span>: y_temp = D[<span class="hljs-number">3</span>];<br><span class="hljs-number">3&#x27;b100</span>: y_temp = D[<span class="hljs-number">4</span>];<br><span class="hljs-number">3&#x27;b101</span>: y_temp = D[<span class="hljs-number">5</span>];<br><span class="hljs-number">3&#x27;b110</span>: y_temp = D[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">default</span>: y_temp = D[<span class="hljs-number">7</span>];<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">assign</span> Y = y_temp;  <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="2-3-8译码器"><a href="#2-3-8译码器" class="headerlink" title="2. 3-8译码器"></a>2. 3-8译码器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Tran_3_8(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] In,<br>    <span class="hljs-keyword">input</span> EN, <span class="hljs-comment">//使能信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Out<br>    );<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] Out_temp;<br><span class="hljs-keyword">always</span> @(In <span class="hljs-keyword">or</span> EN)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(~EN)<br><span class="hljs-keyword">case</span>(In)<br><span class="hljs-number">3&#x27;b000</span>: Out_temp = <span class="hljs-number">8&#x27;b0111_1111</span>;<br><span class="hljs-number">3&#x27;b001</span>: Out_temp = <span class="hljs-number">8&#x27;b1011_1111</span>;<br><span class="hljs-number">3&#x27;b010</span>: Out_temp = <span class="hljs-number">8&#x27;b1101_1111</span>;<br><span class="hljs-number">3&#x27;b011</span>: Out_temp = <span class="hljs-number">8&#x27;b1110_1111</span>;<br><span class="hljs-number">3&#x27;b100</span>: Out_temp = <span class="hljs-number">8&#x27;b1111_0111</span>;<br><span class="hljs-number">3&#x27;b101</span>: Out_temp = <span class="hljs-number">8&#x27;b1111_1011</span>;<br><span class="hljs-number">3&#x27;b110</span>: Out_temp = <span class="hljs-number">8&#x27;b1111_1101</span>;<br><span class="hljs-number">3&#x27;b111</span>: Out_temp = <span class="hljs-number">8&#x27;b1111_1110</span>;<br><span class="hljs-keyword">default</span>: Out_temp = <span class="hljs-number">8&#x27;b1111_1111</span>;<br><span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">else</span><br>Out_temp = <span class="hljs-number">8&#x27;b1111_1111</span>;<br><span class="hljs-keyword">end</span>                                                               <br><span class="hljs-keyword">assign</span> Out = Out_temp;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><h3 id="1-D触发器"><a href="#1-D触发器" class="headerlink" title="1. D触发器"></a>1. D触发器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DFF(S,R,D,CLK,Q,qn);<br>    <br><span class="hljs-keyword">input</span> S,R,D,CLK;<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> Q;<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> qn;<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> CLK <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> S <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> R)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!R) <span class="hljs-keyword">begin</span> Q &lt;= <span class="hljs-number">1&#x27;b0</span>; qn &lt;= <span class="hljs-number">1&#x27;b1</span>; <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!S) <span class="hljs-keyword">begin</span> Q &lt;= <span class="hljs-number">1&#x27;b1</span>; qn &lt;= <span class="hljs-number">1&#x27;b0</span>; <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span> Q &lt;= D; qn &lt;= ~D; <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="2-模M同步二进制加法计数器"><a href="#2-模M同步二进制加法计数器" class="headerlink" title="2. 模M同步二进制加法计数器"></a>2. 模M同步二进制加法计数器</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> cnt_M(clk,rst,cnt);<br><br><span class="hljs-keyword">parameter</span> M = <span class="hljs-number">1024</span>;        <span class="hljs-comment">//M mo</span><br><span class="hljs-keyword">parameter</span> N = <span class="hljs-number">10</span>;          <span class="hljs-comment">//N wei count</span><br><br><span class="hljs-keyword">input</span> clk,rst;<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]cnt;<br><br><span class="hljs-comment">//M wei 10 de count</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!rst) cnt &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt &lt; M-<span class="hljs-number">1</span>) cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span>;<br><span class="hljs-keyword">else</span> cnt &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="3-分频电路"><a href="#3-分频电路" class="headerlink" title="3. 分频电路"></a>3. 分频电路</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Div_Clk(clk,rst,led);<br><br><span class="hljs-keyword">input</span> clk, rst;<br><span class="hljs-keyword">output</span> Div; <br><br><span class="hljs-keyword">reg</span>  [<span class="hljs-number">25</span>:<span class="hljs-number">0</span>]  cnt; <span class="hljs-comment">//计数值</span><br><span class="hljs-keyword">parameter</span> CNT = <span class="hljs-number">32&#x27;d10</span>;  <span class="hljs-comment">//周期为CNT</span><br><span class="hljs-keyword">parameter</span> Half_CNT = <span class="hljs-number">32&#x27;d5</span>;  <span class="hljs-comment">//周期的一半</span><br><span class="hljs-comment">//实际为一个计数器    </span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (!rst) cnt &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt == CNT-<span class="hljs-number">1</span>)  cnt&lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>  cnt &lt;= cnt + <span class="hljs-number">1&#x27;b1</span>; <br><span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">assign</span> led = (cnt &lt; Half_CNT-<span class="hljs-number">1</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br>    <br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h3 id="4-有限状态机"><a href="#4-有限状态机" class="headerlink" title="4. 有限状态机"></a>4. 有限状态机</h3><p>状态机一般包括组合逻辑电路和寄存器两部分。</p><p>状态机的下一个状态的输出不仅与输入信号有关，还与寄存器当前状态有关。</p><p>状态机可以分为米勒（Mealy）型和摩尔（Moore）型。</p><p>Mealy型状态机的输出是当前状态和输入信号的函数，Moore型状态机的输出仅是当前状态的函数。</p><p>下面是一个三段式Moore型状态机。</p><p>在编写一个状态机之前，首先要绘制对应时序逻辑的状态转移图，然后根据状态转移图，编写程序。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> TOP(rst,clk,yout);<br><br><span class="hljs-keyword">input</span> rst,clk;<br><span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] yout;<br><br><span class="hljs-keyword">parameter</span> s0 = <span class="hljs-number">3&#x27;b100</span>, s1 = <span class="hljs-number">3&#x27;b010</span>, s2 = <span class="hljs-number">3&#x27;b001</span>;<span class="hljs-comment">//定义状态机中的所有状态</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] state;<br><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] next_state;<br><br><span class="hljs-comment">//第一个always块，完成状态转换</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> rst)<br><span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span>(!rst)  state &lt;= s0;<br><span class="hljs-keyword">else</span> state &lt;= next_state;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//第二个always块，完成状态机的内部逻辑</span><br><span class="hljs-keyword">always</span> @(state <span class="hljs-keyword">or</span> next state)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(state)<br>        s0: next_state &lt;= s1;<br>        s1: next_state &lt;= s2;<br>        s2: next_state &lt;= s0;<br>        <span class="hljs-keyword">default</span>: next_state &lt;= s0;<br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//状态机的外部输出</span><br><span class="hljs-keyword">always</span> @(*)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(state)<br>        s0: yout &lt;= <span class="hljs-number">2&#x27;b00</span>;<br>        s1: yout &lt;= <span class="hljs-number">2&#x27;b01</span>;<br>        s2: yout &lt;= <span class="hljs-number">2&#x27;b10</span>;<br>        <span class="hljs-keyword">default</span>: yout &lt;= <span class="hljs-number">2&#x27;b00</span>;<br>    <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>FPGA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FPGA</tag>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用方法</title>
    <link href="/2023/06/28/Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/28/Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>git使用方法</p><span id="more"></span><h1 id="Git使用方法"><a href="#Git使用方法" class="headerlink" title="Git使用方法"></a>Git使用方法</h1><p>git：分布式版本控制系统</p><h2 id="Git与GIithub远程仓库连接（配置SSH）"><a href="#Git与GIithub远程仓库连接（配置SSH）" class="headerlink" title="Git与GIithub远程仓库连接（配置SSH）"></a>Git与GIithub远程仓库连接（配置SSH）</h2><p>（ssh是一种网络协议，用于计算机之间的加密登录）</p><p>以下为成功安装git后的操作</p><h3 id="配置注册用户名和注册邮箱"><a href="#配置注册用户名和注册邮箱" class="headerlink" title="配置注册用户名和注册邮箱"></a>配置注册用户名和注册邮箱</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;xxx&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;xxx.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><h3 id="生成SSH"><a href="#生成SSH" class="headerlink" title="生成SSH"></a>生成SSH</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><h3 id="获取公钥"><a href="#获取公钥" class="headerlink" title="获取公钥"></a>获取公钥</h3><p>SSH文件存放于C:&#x2F;User&#x2F;用户&#x2F;.ssh，其中id_rsa为私钥，id_rsa.pub为公钥。</p><p>复制公钥，在GitHub-&gt;Setting-&gt;SSH and GPG keys-&gt;New SSH key，创建一个新的SSH key。</p><p>测试SSH连接</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><h2 id="推送文章到远程仓库"><a href="#推送文章到远程仓库" class="headerlink" title="推送文章到远程仓库"></a>推送文章到远程仓库</h2><h3 id="在Github上建立新仓库"><a href="#在Github上建立新仓库" class="headerlink" title="在Github上建立新仓库"></a>在Github上建立新仓库</h3><p>“+”-&gt;New respository</p><h3 id="建立本地仓库"><a href="#建立本地仓库" class="headerlink" title="建立本地仓库"></a>建立本地仓库</h3><p>在目录中新建一个文件夹Git，右键选择Git bash here，执行命令</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>将Git文件夹初始化为一个仓库，此时Git文件夹下会出现一个隐藏的.git文件夹。</p><h3 id="将远程仓库克隆到本地"><a href="#将远程仓库克隆到本地" class="headerlink" title="将远程仓库克隆到本地"></a>将远程仓库克隆到本地</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:用户名/仓库名.git<br></code></pre></td></tr></table></figure><h3 id="管理仓库中文件"><a href="#管理仓库中文件" class="headerlink" title="管理仓库中文件"></a>管理仓库中文件</h3><h3 id="命令add"><a href="#命令add" class="headerlink" title="命令add"></a>命令add</h3><p>在仓库文件夹下git bash here，执行命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> 单个文件<br>git <span class="hljs-built_in">add</span> 文件夹1/ 文件夹2/ <span class="hljs-built_in">..</span>.<br>git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><h3 id="命令commit"><a href="#命令commit" class="headerlink" title="命令commit"></a>命令commit</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;注释&quot;</span><br></code></pre></td></tr></table></figure><h3 id="命令push"><a href="#命令push" class="headerlink" title="命令push"></a>命令push</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p>至此，便完成了“远程仓库的建立-&gt;本地仓库克隆-&gt;管理仓库-&gt;推送本地仓库到远程”的过程。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕设Matlab笔记</title>
    <link href="/2023/06/26/%E6%AF%95%E8%AE%BEMatlab%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/26/%E6%AF%95%E8%AE%BEMatlab%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>毕设Matlab笔记</p><span id="more"></span><h1 id="Matlab-笔记"><a href="#Matlab-笔记" class="headerlink" title="Matlab 笔记"></a>Matlab 笔记</h1><h2 id="一、PA建模"><a href="#一、PA建模" class="headerlink" title="一、PA建模"></a>一、PA建模</h2><p>本例使用NXP Airfast LDMOS Doherty PA，工作频率3.6-3.8 GHz，增益29 dB。</p><h2 id="1、无记忆非线性模型阅读"><a href="#1、无记忆非线性模型阅读" class="headerlink" title="1、无记忆非线性模型阅读"></a>1、无记忆非线性模型阅读</h2><p>导入原始测量的功放输入输出数据（复数形式）</p><p>对输入输出数据取绝对值，然后转换为dBm</p><p>对数据进行统计histcounts，直方图</p><p>求输入数据最大值-20</p><p>找出满足条件的边缘数据的位置</p><p>建立新的表格存储满足条件的数据值</p><p>分别求输入功率，输出功率，相移的平均值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs matlab">sampleRate = <span class="hljs-number">860160000</span>;<br><br><span class="hljs-comment">%数据转换</span><br>paInputdBm  = mag2db(<span class="hljs-built_in">abs</span>(paInput)) + <span class="hljs-number">30</span> - <span class="hljs-number">20</span>;<br>paOutputdBm  = mag2db(<span class="hljs-built_in">abs</span>(paOutput)) + <span class="hljs-number">30</span> - <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">%准备建模数据</span><br>[N,edges,idx] = histcounts(paInputdBm, <span class="hljs-string">&#x27;BinWidth&#x27;</span>, <span class="hljs-number">0.5</span>);  <span class="hljs-comment">%hiscounts函数，直方图bin计数</span><br>minInPowerdBm = <span class="hljs-built_in">max</span>(paInputdBm) - <span class="hljs-number">20</span>;  <span class="hljs-comment">%输入功率值不能小于最大输入功率20db</span><br>minIdx = <span class="hljs-built_in">find</span>(edges &lt; minInPowerdBm, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;last&#x27;</span>);<br>tableLen = <span class="hljs-built_in">length</span>(edges)-minIdx<span class="hljs-number">-1</span>;<br>inOutTable = <span class="hljs-built_in">zeros</span>(tableLen,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> p = minIdx+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(edges)<span class="hljs-number">-1</span><br>inOutTable(p-minIdx,<span class="hljs-number">1</span>) = <span class="hljs-built_in">mean</span>(paInputdBm(idx == p));   <span class="hljs-comment">% Average input power for current bin</span><br>inOutTable(p-minIdx,<span class="hljs-number">2</span>) = <span class="hljs-built_in">mean</span>(paOutputdBm(idx == p));  <span class="hljs-comment">% Average output power for current bin</span><br>inOutTable(p-minIdx,<span class="hljs-number">3</span>) = <span class="hljs-built_in">mean</span>(<span class="hljs-built_in">angle</span>(paOutput(idx == p)./paInput(idx == p))); <span class="hljs-comment">% Average phase shift for current                                                                                       bin</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">%建立模型</span><br>pa = comm.MemorylessNonlinearity(<span class="hljs-string">&#x27;Method&#x27;</span>,<span class="hljs-string">&#x27;Lookup table&#x27;</span>,<span class="hljs-string">&#x27;Table&#x27;</span>,inOutTable,<span class="hljs-string">&#x27;ReferenceImpedance&#x27;</span>,<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">%计算模型输出</span><br>paOutputFitMemless = pa(paInput);<br><span class="hljs-comment">%计算误差</span><br>err = <span class="hljs-built_in">abs</span>(paOutput - paOutputFitMemless)./<span class="hljs-built_in">abs</span>(paOutput);<br>rmsErrorMemless = rms(err)*<span class="hljs-number">100</span>;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;Percent RMS error in time domain is &#x27;</span> num2str(rmsErrorMemless) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><span class="hljs-comment">%绘制图形观察</span><br>helperPACharPlotTime(paOutput, paOutputFitMemless, sampleRate);<br>helperPACharPlotGain(paInput, paOutput, paOutputFitMemless);<br><br></code></pre></td></tr></table></figure><h2 id="2、记忆多项式模型阅读"><a href="#2、记忆多项式模型阅读" class="headerlink" title="2、记忆多项式模型阅读"></a>2、记忆多项式模型阅读</h2><p>程序阅读</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab">modType = <span class="hljs-string">&#x27;memPoly&#x27;</span>; <span class="hljs-comment">%记忆多项式模型</span><br>memLen = <span class="hljs-number">5</span>;     <span class="hljs-comment">% M = 5</span><br>degLen = <span class="hljs-number">5</span>;     <span class="hljs-comment">% K = 5</span><br>numDataPts = <span class="hljs-built_in">length</span>(paInput);<br>halfDataPts = <span class="hljs-built_in">round</span>(numDataPts/<span class="hljs-number">2</span>);<br>fitCoefMatMem = helperPACharMemPolyModel(<span class="hljs-string">&#x27;coefficientFinder&#x27;</span>,paInput(<span class="hljs-number">1</span>:halfDataPts),paOutput(<span class="hljs-number">1</span>:halfDataPts),memLen,degLen,modType);<br><span class="hljs-built_in">disp</span>(<span class="hljs-built_in">abs</span>(fitCoefMatMem));<br><br>rmsErrorTimeMem = helperPACharMemPolyModel(<span class="hljs-string">&#x27;errorMeasure&#x27;</span>,paInput, paOutput, fitCoefMatMem, modType);<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;Percent RMS error in time domain is &#x27;</span> num2str(rmsErrorTimeMem) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br>paOutputFitMem = helperPACharMemPolyModel(<span class="hljs-string">&#x27;signalGenerator&#x27;</span>, paInput, fitCoefMatMem, modType);<br><br>helperPACharPlotTime(paOutput, paOutputFitMem, sampleRate);<br>helperPACharPlotGain(paInput, paOutput, paOutputFitMem);<br><br><br><br></code></pre></td></tr></table></figure><p>我的程序</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%x = (0 : 3);</span><br>x = paInput;<br>x = x(:);<br>xLength = <span class="hljs-built_in">length</span>(x);<br><br><span class="hljs-comment">%y = (2 : 5);</span><br>y = paOutput;<br>y = y(:);<br>yLength = <span class="hljs-built_in">length</span>(y);<br><br>M = <span class="hljs-number">3</span>;<br>K = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">%构造(x(n) - m)矩阵，m从0到M-1, 矩阵大小为xLength*M</span><br>xm = x;<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">0</span> : M - <span class="hljs-number">1</span><br>    xm(M:xLength , m+<span class="hljs-number">1</span>) = xm(M-m:xLength-m , <span class="hljs-number">1</span>) ;<br><span class="hljs-keyword">end</span><br>xm_fix = xm; <span class="hljs-comment">%保存(x(n) - m)矩阵</span><br><br><span class="hljs-comment">%构造(x(n) - m) * |x(n) - m|^k 矩阵，矩阵大小为(xLength-M+1)*（M*K）</span><br>xmAbs = <span class="hljs-built_in">abs</span>(xm);<span class="hljs-comment">%保存|x - m|矩阵</span><br><span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span> : K<span class="hljs-number">-1</span><br>    mid = (xmAbs.^ k) .* xm_fix;<br>    xm = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>, xm, mid);<br><span class="hljs-keyword">end</span><br>xmk = xm(M:xLength,:);<br><br><span class="hljs-comment">%计算系数矩阵，矩阵大小为（M*K） * 1</span><br>coef = xmk \ y(M:xLength);<br><br><span class="hljs-comment">%带入求解yout矩阵，矩阵大小为xLength*1</span><br>yout = xm * coef;<br><br><span class="hljs-comment">% helperPACharPlotTime(y, yout, 860160000);</span><br><span class="hljs-comment">% helperPACharPlotGain(x, y, yout);</span><br><br><br><span class="hljs-comment">%通过归一化均方误差衡量功放的建模精度</span><br>NMSE = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>( sum ( (<span class="hljs-built_in">abs</span>(y - yout)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(y).^<span class="hljs-number">2</span>) ) ) ;<br><br><br><br><span class="hljs-comment">%AM/AM图绘制</span><br><span class="hljs-comment">%单位转换</span><br>paInputPowerdBm = mag2db(<span class="hljs-built_in">abs</span>(x)) + <span class="hljs-number">30</span> - <span class="hljs-number">20</span>;<br>paOutputPowerdBm = mag2db(<span class="hljs-built_in">abs</span>(y)) + <span class="hljs-number">30</span> - <span class="hljs-number">20</span>;<br>paOutputPowerFitdBm = mag2db(<span class="hljs-built_in">abs</span>(yout)) + <span class="hljs-number">30</span> - <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">%去除噪点</span><br>inputPowerRange = <span class="hljs-number">20</span>;<br>idxToDiscard = paInputPowerdBm &lt; (<span class="hljs-built_in">max</span>(paInputPowerdBm)-inputPowerRange);<span class="hljs-comment">%去除掉与最大输入功率相差20的点</span><br><br>paInputPowerdBm(idxToDiscard) = [];<br>paOutputPowerdBm(idxToDiscard) = [];<br>paOutputPowerFitdBm(idxToDiscard) = [];<br><br><span class="hljs-built_in">plot</span>(paInputPowerdBm, paOutputPowerdBm, <span class="hljs-string">&#x27;o&#x27;</span>, paInputPowerdBm,paOutputPowerFitdBm, <span class="hljs-string">&#x27;.&#x27;</span>)<br>grid on<br>xlabel(<span class="hljs-string">&#x27;Input Power (dBm)&#x27;</span>)<br>ylabel(<span class="hljs-string">&#x27;Output Power (dBm)&#x27;</span>)<br>title(<span class="hljs-string">&#x27;AM/AM&#x27;</span>)<br><br><span class="hljs-comment">%AM/PM图绘制</span><br>paInputPhase = <span class="hljs-built_in">angle</span>(x);<br>paOutputPhase = <span class="hljs-built_in">angle</span>(y);<br>paOutputPhaseFit = <span class="hljs-built_in">angle</span>(yout);<br><br>paInputPhase(idxToDiscard) = [];<br>paOutputPhase(idxToDiscard) = [];<br>paOutputPhaseFit(idxToDiscard) = [];<br><br>paPhaseChange =  paInputPhase - paOutputPhase;<br>paPhaseChangeFit =paOutputPhaseFit - paOutputPhase;<br><br><span class="hljs-comment">%将角度集中在-pi-pi之间</span><br>lambdaWrapped = wrapToPi(paPhaseChange);<br>lambdaWrapped2 = wrapToPi(paPhaseChangeFit);<br><br><span class="hljs-built_in">plot</span>(paInputPowerdBm, lambdaWrapped, <span class="hljs-string">&#x27;o&#x27;</span>, paInputPowerdBm,lambdaWrapped2, <span class="hljs-string">&#x27;.&#x27;</span>)<br>grid on<br>xlabel(<span class="hljs-string">&#x27;Input Power (dBm)&#x27;</span>)<br>ylabel(<span class="hljs-string">&#x27;Phase Change&#x27;</span>)<br>title(<span class="hljs-string">&#x27;AM/PM&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="我的程序"><a href="#我的程序" class="headerlink" title="我的程序"></a>我的程序</h2><h3 id="1、毕设论文1-矩阵处理函数"><a href="#1、毕设论文1-矩阵处理函数" class="headerlink" title="1、毕设论文1_矩阵处理函数"></a>1、毕设论文1_矩阵处理函数</h3><h4 id="1、改进后模型"><a href="#1、改进后模型" class="headerlink" title="1、改进后模型"></a>1、改进后模型</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[Xout]</span> = <span class="hljs-title">MatrixDeal</span><span class="hljs-params">(x,M,K)</span></span><br><br><br><span class="hljs-comment">%构造x(n - m)矩阵，m从1到M, 矩阵大小为xLength*M,有效长度为Xlength-M</span><br>xnm = x;<br>xhalfLength = <span class="hljs-built_in">length</span>(xnm);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">1</span> : M<br>    xnm(M+<span class="hljs-number">1</span>:xhalfLength , m) = x(M-m+<span class="hljs-number">1</span>:xhalfLength-m , <span class="hljs-number">1</span>) ;  <span class="hljs-comment">%(m从1-M)</span><br><span class="hljs-keyword">end</span><br><br>xnm_fix = xnm; <span class="hljs-comment">%保存x(n - m)矩阵</span><br>xnm_fixabs = <span class="hljs-built_in">abs</span>(xnm_fix);<span class="hljs-comment">%保存 |x(n - m)| 矩阵</span><br><br>xn_fix = x;<span class="hljs-comment">%保存 x(n) 矩阵</span><br>xn_fixabs = <span class="hljs-built_in">abs</span>(xn_fix);<span class="hljs-comment">%保存 |x(n)| 矩阵</span><br><br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-comment">%m从0开始到M</span><br>xnm_0 = x;<br>xhalfLength = <span class="hljs-built_in">length</span>(xnm_0);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">0</span> : M<br>    xnm_0(M+<span class="hljs-number">1</span>:xhalfLength , m+<span class="hljs-number">1</span>) = x(M-m+<span class="hljs-number">1</span>:xhalfLength-m , <span class="hljs-number">1</span>) ;  <span class="hljs-comment">%(m从1-M)</span><br><span class="hljs-keyword">end</span><br>xnm_fix_0 = xnm_0; <span class="hljs-comment">%保存x(n - m)矩阵</span><br>xnm_fixabs_0 = <span class="hljs-built_in">abs</span>(xnm_fix_0);<span class="hljs-comment">%保存 |x(n - m)| 矩阵</span><br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><br><span class="hljs-comment">%构造Bk矩阵</span><br>Bk = (<span class="hljs-number">0</span>:K<span class="hljs-number">-1</span>);<br>Bk = Bk/K;<br><br><br><span class="hljs-comment">%f0</span><br><span class="hljs-comment">%构造 x(n-m)矩阵，矩阵大小为xLength * (M*k)</span><br><span class="hljs-comment">% X1 = xnm_fix(M+1:xhalfLength,:);</span><br><br>X1 = xnm_fix_0(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><span class="hljs-comment">%F21</span><br><span class="hljs-comment">%构造| ( |x(n-m)| - Bk ) | * x(n - m) * |x(n)| 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_F21 = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xnm_fix .* xn_fixabs;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(k) ) .* xnm_fix .* xn_fixabs;<br>    xmk_F21 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_F21,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X2 = xmk_F21(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%f22</span><br><span class="hljs-comment">%构造 | ( |x(n-m)| - Bk ) | * x(n) 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f22 = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xn_fix;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(k) ) .* xn_fix;<br>    xmk_f22 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f22,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X3 = xmk_f22(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%F23</span><br><span class="hljs-comment">%构造  | ( |x(n-m)| - Bk ) | * x(n-m) 矩阵，矩阵大小为xLength * (M*k)</span><br><span class="hljs-comment">% xmk_F23 = abs( xnm_fixabs - Bk(1) ) .* xnm_fix;</span><br><span class="hljs-comment">% for k = 2 : K</span><br><span class="hljs-comment">%     mid = abs( xnm_fixabs - Bk(k) ) .* xnm_fix;</span><br><span class="hljs-comment">%     xmk_F23 = cat(2,xmk_F23,mid);</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% %矩阵大小为(xLength-M) * (M*K)</span><br><span class="hljs-comment">% X4 = xmk_F23(M+1:xhalfLength,:);</span><br><br><br><br>xmk_F23 = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(<span class="hljs-number">1</span>) ) .* xnm_fix_0;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(k) ) .* xnm_fix_0;<br>    xmk_F23 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_F23,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X4 = xmk_F23(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%f24</span><br><span class="hljs-comment">%构造 | ( |x(n)| - Bk ) | * x(n-m) 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f24 = <span class="hljs-built_in">abs</span>( xn_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xnm_fix;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xn_fixabs - Bk(k) ) .* xnm_fix;<br>    xmk_f24 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f24,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X5 = xmk_f24(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%合并矩阵，矩阵大小为(xLength-M) *（M*K*4+M） </span><br>Xout = [X1 X2 X3 X4 X5];<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="2、DVR模型"><a href="#2、DVR模型" class="headerlink" title="2、DVR模型"></a>2、DVR模型</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[Xout]</span> = <span class="hljs-title">MatrixDeal_DVR</span><span class="hljs-params">(x,M,K)</span></span><br><br><br><span class="hljs-comment">%构造x(n - m)矩阵，m从1到M, 矩阵大小为xLength*M,有效长度为Xlength-M-1</span><br>xnm = x;<br>xhalfLength = <span class="hljs-built_in">length</span>(xnm);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">1</span> : M<br>    xnm(M+<span class="hljs-number">1</span>:xhalfLength , m) = x(M-m+<span class="hljs-number">1</span>:xhalfLength-m , <span class="hljs-number">1</span>) ;<br><span class="hljs-keyword">end</span><br><br>xnm_fix = xnm; <span class="hljs-comment">%保存x(n - m)矩阵</span><br>xnm_fixabs = <span class="hljs-built_in">abs</span>(xnm_fix);<span class="hljs-comment">%保存 |x(n - m)| 矩阵</span><br>    <br>xn_fix = x;<span class="hljs-comment">%保存 x(n) 矩阵</span><br>xn_fixabs = <span class="hljs-built_in">abs</span>(xn_fix);<span class="hljs-comment">%保存 |x(n)| 矩阵</span><br><br><span class="hljs-comment">%构造Bk矩阵</span><br>Bk = (<span class="hljs-number">0</span>:K<span class="hljs-number">-1</span>);<br>Bk = Bk/K;<br><br><br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="hljs-comment">%m从0开始到M</span><br>xnm_0 = x;<br>xhalfLength = <span class="hljs-built_in">length</span>(xnm_0);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">0</span> : M<br>    xnm_0(M+<span class="hljs-number">1</span>:xhalfLength , m+<span class="hljs-number">1</span>) = x(M-m+<span class="hljs-number">1</span>:xhalfLength-m , <span class="hljs-number">1</span>) ;  <span class="hljs-comment">%(m从1-M)</span><br><span class="hljs-keyword">end</span><br>xnm_fix_0 = xnm_0; <span class="hljs-comment">%保存x(n - m)矩阵</span><br>xnm_fixabs_0 = <span class="hljs-built_in">abs</span>(xnm_fix_0);<span class="hljs-comment">%保存 |x(n - m)| 矩阵</span><br><span class="hljs-comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><br><br><span class="hljs-comment">% %构造xAngle(n-m)矩阵</span><br><span class="hljs-comment">% xAngle = angle(xnm);</span><br><span class="hljs-comment">% for m = 1 : M</span><br><span class="hljs-comment">%     xAngle(M+1:xhalfLength , m) = xAngle(M-m+1:xhalfLength-m , 1) ;</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% xAngle_fix = 1i * xAngle;%保存i * xAngle(n-m)矩阵</span><br><br><span class="hljs-comment">%构造xAngle(n-m)矩阵</span><br>xAngle = <span class="hljs-built_in">angle</span>(xnm);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">0</span> : M<br>    xAngle(M+<span class="hljs-number">1</span>:xhalfLength , m+<span class="hljs-number">1</span>) = xAngle(M-m+<span class="hljs-number">1</span>:xhalfLength-m , <span class="hljs-number">1</span>) ;<br><span class="hljs-keyword">end</span><br>xAngle_fix = <span class="hljs-number">1</span><span class="hljs-built_in">i</span> * xAngle;<span class="hljs-comment">%保存i * xAngle(n-m)矩阵</span><br><br><span class="hljs-comment">%f0</span><br><span class="hljs-comment">%构造 x(n-m)矩阵，矩阵大小为xLength * (M*k)</span><br><span class="hljs-comment">% X1 = xnm_fix(M+1:xhalfLength,:);</span><br><br>X1 = xnm_fix_0(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><span class="hljs-comment">% %f1</span><br><span class="hljs-comment">% %构造 | ( |x(n-m)| - Bk ) | * e^(xAngle_fix) 矩阵</span><br><span class="hljs-comment">% xmk_f1 = abs( xnm_fixabs - Bk(1) ) .* exp(xAngle_fix);</span><br><span class="hljs-comment">% for k = 2 : K</span><br><span class="hljs-comment">%     mid = abs( xnm_fixabs - Bk(k) ) .* exp(xAngle_fix);</span><br><span class="hljs-comment">%     xmk_f1 = cat(2,xmk_f1,mid);</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% X2 = xmk_f1(M+1:xhalfLength,:);</span><br><br><span class="hljs-comment">%f1</span><br><span class="hljs-comment">%构造 | ( |x(n-m)| - Bk ) | * e^(xAngle_fix) 矩阵</span><br>xmk_f1 = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(<span class="hljs-number">1</span>) ) .* <span class="hljs-built_in">exp</span>(xAngle_fix);<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(k) ) .* <span class="hljs-built_in">exp</span>(xAngle_fix);<br>    xmk_f1 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f1,mid);<br><span class="hljs-keyword">end</span><br>X2 = xmk_f1(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">% %f21</span><br><span class="hljs-comment">% %构造| ( |x(n-m)| - Bk ) | * e^(xAngle_fix) * |x(n)| 矩阵，矩阵大小为xLength * (M*k)</span><br><span class="hljs-comment">% xmk_f21 = abs( xnm_fixabs - Bk(1) ) .* exp(xAngle_fix) .* xn_fixabs;</span><br><span class="hljs-comment">% for k = 2 : K</span><br><span class="hljs-comment">%     mid = abs( xnm_fixabs - Bk(k) ) .* exp(xAngle_fix) .* xn_fixabs;</span><br><span class="hljs-comment">%     xmk_f21 = cat(2,xmk_f21,mid);</span><br><span class="hljs-comment">% end</span><br><span class="hljs-comment">% %矩阵大小为(xLength-M) * (M*K)</span><br><span class="hljs-comment">% X3 = xmk_f21(M+1:xhalfLength,:);</span><br><br><span class="hljs-comment">%f21</span><br><span class="hljs-comment">%构造| ( |x(n-m)| - Bk ) | * e^(xAngle_fix) * |x(n)| 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f21 = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(<span class="hljs-number">1</span>) ) .* <span class="hljs-built_in">exp</span>(xAngle_fix) .* xn_fixabs;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs_0 - Bk(k) ) .* <span class="hljs-built_in">exp</span>(xAngle_fix) .* xn_fixabs;<br>    xmk_f21 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f21,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X3 = xmk_f21(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%f22</span><br><span class="hljs-comment">%构造| ( |x(n-m)| - Bk ) | * x(n) 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f22 = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xn_fix;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(k) ) .* xn_fix;<br>    xmk_f22 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f22,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X4 = xmk_f22(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%f23</span><br><span class="hljs-comment">%构造| ( |x(n-m)| - Bk ) | * x(n-m) 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f23 = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xnm_fix;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xnm_fixabs - Bk(k) ) .* xnm_fix;<br>    xmk_f23 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f23,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X5 = xmk_f23(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><br><span class="hljs-comment">%f24</span><br><span class="hljs-comment">%构造 | ( |x(n-m)| - Bk ) | * x(n-m) 矩阵，矩阵大小为xLength * (M*k)</span><br>xmk_f24 = <span class="hljs-built_in">abs</span>( xn_fixabs - Bk(<span class="hljs-number">1</span>) ) .* xnm_fix;<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">2</span> : K<br>    mid = <span class="hljs-built_in">abs</span>( xn_fixabs - Bk(k) ) .* xnm_fix;<br>    xmk_f24 = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>,xmk_f24,mid);<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>X6 = xmk_f24(M+<span class="hljs-number">1</span>:xhalfLength,:);<br><br><span class="hljs-comment">%合并矩阵，矩阵大小为(xLength-M) *（M*K*4+M） </span><br>Xout = [X1 X2 X3 X4 X5 X6];<br><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="3、记忆多项式"><a href="#3、记忆多项式" class="headerlink" title="3、记忆多项式"></a>3、记忆多项式</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[Xout]</span> = <span class="hljs-title">MatrixDeal_MP</span><span class="hljs-params">(x,M,K)</span></span><br><span class="hljs-comment">%UNTITLED 此处提供此函数的摘要</span><br><span class="hljs-comment">%   此处提供详细说明</span><br><br><br><span class="hljs-comment">%构造(x(n) - m)矩阵，m从0到M-1, 矩阵大小为xLength*M</span><br>xm = x;<br>xmLength = <span class="hljs-built_in">length</span>(xm);<br><span class="hljs-keyword">for</span> m = <span class="hljs-number">0</span> : M - <span class="hljs-number">1</span><br>    xm(M:xmLength , m+<span class="hljs-number">1</span>) = xm(M-m:xmLength-m , <span class="hljs-number">1</span>) ;<span class="hljs-comment">%有效数据从第M行开始</span><br><span class="hljs-keyword">end</span><br>xm_fix = xm; <span class="hljs-comment">%保存(x(n) - m)矩阵</span><br><br><span class="hljs-comment">%构造(x(n) - m) * |x(n) - m|^k 矩阵，矩阵大小为(xLength-M+1)*（M*K）</span><br>xmAbs = <span class="hljs-built_in">abs</span>(xm_fix);<span class="hljs-comment">%保存|x - m|矩阵</span><br><span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span> : K<span class="hljs-number">-1</span><br>    mid = (xmAbs.^ k) .* xm_fix;<br>    xm = <span class="hljs-built_in">cat</span>(<span class="hljs-number">2</span>, xm, mid);<br><span class="hljs-keyword">end</span><br>xmk = xm(M:xmLength,:);<br><br><span class="hljs-comment">%矩阵大小为(xLength-M) * (M*K)</span><br>Xout = xmk;<br><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="2、毕设论文1-绘图函数"><a href="#2、毕设论文1-绘图函数" class="headerlink" title="2、毕设论文1_绘图函数"></a>2、毕设论文1_绘图函数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span>   <span class="hljs-title">paCharPlot</span><span class="hljs-params">(paInput,paOutput,paOutputFit,Type)</span></span><br><br>paInputMagnitude = <span class="hljs-built_in">abs</span>(paInput) ;<br>paOutputMagnitude = <span class="hljs-built_in">abs</span>(paOutput) ;<br>paOutputMagnitudeFit = <span class="hljs-built_in">abs</span>(paOutputFit) ;<br><br>idxToDiscard = paOutputMagnitudeFit &gt; <span class="hljs-number">1</span> | paOutputMagnitude &gt; <span class="hljs-number">1</span>;<br>paInputMagnitude(idxToDiscard) = [];<br>paOutputMagnitude(idxToDiscard) = [];<br>paOutputMagnitudeFit(idxToDiscard) = [];<br><br>paGain = paOutputMagnitude - paInputMagnitude;<br>paGainFit = paOutputMagnitudeFit - paInputMagnitude;<br><br><br><span class="hljs-comment">%AM/PM图绘制</span><br>paInputPhase = <span class="hljs-built_in">angle</span>(paInput);<br>paOutputPhase = <span class="hljs-built_in">angle</span>(paOutput);<br>paOutputPhaseFit = <span class="hljs-built_in">angle</span>(paOutputFit);<br><br>paInputPhase(idxToDiscard) = [];<br>paOutputPhase(idxToDiscard) = [];<br>paOutputPhaseFit(idxToDiscard) = [];<br><br>paPhaseChange =  paInputPhase - paOutputPhase;<br>paPhaseChangeFit =paInputPhase - paOutputPhaseFit;<br><br><span class="hljs-comment">%将角度数据集中在-pi-pi之间</span><br>lambdaWrapped = wrapToPi(paPhaseChange);<br>lambdaWrappedFit = wrapToPi(paPhaseChangeFit);    <br><br><span class="hljs-comment">% lambdaWrapped = rad2deg(lambdaWrapped);</span><br><span class="hljs-comment">% lambdaWrapped2 = rad2deg(lambdaWrapped2);</span><br><br><br><span class="hljs-keyword">switch</span> Type<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;AM/AM&#x27;</span><br>        <span class="hljs-built_in">figure</span>;<br>        <span class="hljs-built_in">plot</span>(paInputMagnitude, paOutputMagnitude, <span class="hljs-string">&#x27;.&#x27;</span>, paInputMagnitude,paOutputMagnitudeFit, <span class="hljs-string">&#x27;.&#x27;</span>)<br>        grid on<br>        xlabel(<span class="hljs-string">&#x27;Input Magnitude&#x27;</span>)<br>        ylabel(<span class="hljs-string">&#x27;Output Magnitude&#x27;</span>)<br>        <span class="hljs-built_in">legend</span>(&#123;<span class="hljs-string">&#x27;Actual&#x27;</span>,<span class="hljs-string">&#x27;Model/Linear&#x27;</span>&#125;,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;northwest&#x27;</span>)<br>        title(<span class="hljs-string">&#x27;AM/AM&#x27;</span>)<br><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;PM/AM&#x27;</span><br>        <span class="hljs-built_in">figure</span>;<br>        <span class="hljs-built_in">plot</span>(paInputMagnitude, lambdaWrapped, <span class="hljs-string">&#x27;.&#x27;</span>, paInputMagnitude,lambdaWrappedFit, <span class="hljs-string">&#x27;.&#x27;</span>)<br>        grid on<br>        xlabel(<span class="hljs-string">&#x27;Input Magnitude&#x27;</span>)<br>        ylabel(<span class="hljs-string">&#x27;Phase Change&#x27;</span>)<br>        <span class="hljs-built_in">legend</span>(&#123;<span class="hljs-string">&#x27;Actual&#x27;</span>,<span class="hljs-string">&#x27;Model/Linear&#x27;</span>&#125;,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;northwest&#x27;</span>)<br>        title(<span class="hljs-string">&#x27;AM/PM&#x27;</span>)<br><br>       <br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Gain&#x27;</span><br>        <span class="hljs-built_in">figure</span>;<br>        <span class="hljs-built_in">plot</span>(paInputMagnitude, paGain, <span class="hljs-string">&#x27;.&#x27;</span>, paInputMagnitude,paGainFit, <span class="hljs-string">&#x27;.&#x27;</span>)<br>        grid on<br>        xlabel(<span class="hljs-string">&#x27;Input Magnitude&#x27;</span>)<br>        ylabel(<span class="hljs-string">&#x27;Gain&#x27;</span>)<br>        <span class="hljs-built_in">legend</span>(&#123;<span class="hljs-string">&#x27;Actual&#x27;</span>,<span class="hljs-string">&#x27;Model/Linear&#x27;</span>&#125;,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;northwest&#x27;</span>)<br>        title(<span class="hljs-string">&#x27;PA Gain&#x27;</span>)<br><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Couple&#x27;</span><br>        yyaxis left;<br>        <span class="hljs-built_in">plot</span>(paInputPowerdBm, paOutputPowerdBm, <span class="hljs-string">&#x27;o&#x27;</span>, paInputPowerdBm,paOutputPowerFitdBm, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        yyaxis right;<br>        <span class="hljs-built_in">plot</span>(paInputPowerdBm, lambdaWrapped, <span class="hljs-string">&#x27;o&#x27;</span>, paInputPowerdBm,lambdaWrapped2, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-built_in">hold</span> on<br><br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="3、毕设论文1-模型建立"><a href="#3、毕设论文1-模型建立" class="headerlink" title="3、毕设论文1_模型建立"></a>3、毕设论文1_模型建立</h3><h4 id="1、改进后模型-1"><a href="#1、改进后模型-1" class="headerlink" title="1、改进后模型"></a>1、改进后模型</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%本例使用NXP Airfast LDMOS Doherty PA，工作频率3.6-3.8 GHz，增益29 dB。</span><br><span class="hljs-comment">%带宽100MHZ    100000000</span><br><span class="hljs-comment">%采样率sampleRate = 860160000</span><br><span class="hljs-comment">%信号类型OFDM</span><br><span class="hljs-comment">%If testSignal is &quot;OFDM&quot;, this example uses a 5G-like OFDM waveform with 64-QAM modulated signals for each subcarrier.</span><br><span class="hljs-comment">% If testSignal is &quot;Tones&quot;, this example uses two tones at 1.8 MHz and 2.6 MHz, to test the intermodulation caused by the PA.</span><br><br><br>sampleRate = <span class="hljs-number">860160000</span>;<br><span class="hljs-comment">% sampleRate = 430080000;</span><br>testSignal = <span class="hljs-string">&#x27;OFDM&#x27;</span>;<br><br><span class="hljs-comment">%读取数据</span><br><span class="hljs-comment">% x = (0 : 5);</span><br>x = paInput;<br><span class="hljs-comment">% x = txData1;</span><br><span class="hljs-comment">% x = paInput_40MHZ;</span><br>x = x(:);<br>xLength = <span class="hljs-built_in">length</span>(x);<br><span class="hljs-comment">%使用前半部分数据用于参数提取，后半部分数据用于模型验证</span><br>half = <span class="hljs-built_in">round</span>(xLength/<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% y = (2 : 7);</span><br>y = paOutput;<br><span class="hljs-comment">% y = tout;</span><br><span class="hljs-comment">% y = paOutput_40MHZ;</span><br>y = y(:);<br>yLength = <span class="hljs-built_in">length</span>(y);<br><br><span class="hljs-comment">%将数据归一化</span><br><span class="hljs-comment">% x = x / abs(max(x));</span><br><span class="hljs-comment">% y = y / abs(max(y));</span><br><br>M = <span class="hljs-number">2</span>;<br>K = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">%计算PA系数矩阵，矩阵大小为（M*K*4+M） * 1</span><br><br><span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>XcoefPA = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <br>YcoefPA = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefPA = x(1:half);  </span><br><span class="hljs-comment">% YcoefPA = y(1:half);  </span><br><br><span class="hljs-comment">%去除多余数据</span><br>YcoefPA = YcoefPA(M+<span class="hljs-number">1</span>:half) ;                   <span class="hljs-comment">%经过处理后，数据去除掉前M个</span><br>coefPA = MatrixDeal(XcoefPA,M,K) \ YcoefPA;<br><br><span class="hljs-comment">%最小二乘算法</span><br><span class="hljs-comment">% coefPA  = inv( (XcoefPA&#x27;) *XcoefPA ) * (XcoefPA&#x27;) * YcoefPA;</span><br><span class="hljs-comment">% coefPA  = ( (XcoefPA&#x27;) *XcoefPA ) \ (XcoefPA&#x27;) * YcoefPA;</span><br><br><span class="hljs-comment">%带入验证PA模型输出，矩阵大小为xLength*1</span><br>XmodelPA = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );      <span class="hljs-comment">%使用后一半的数据验证模型，将数据归一化</span><br>YmodelPA = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><br><span class="hljs-comment">% XmodelPA = x(half:xLength);      %使用后一半的数据验证模型，将数据归一化</span><br><span class="hljs-comment">% YmodelPA = y(half:xLength); </span><br><br>YmodelFitPA = MatrixDeal(XmodelPA,M,K) * coefPA;   <span class="hljs-comment">%计算模型输出（输出后的数据减少前M个）</span><br><br><span class="hljs-comment">%去除多余数据</span><br>XmodelPA = XmodelPA(M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(XmodelPA));<br>YmodelPA = YmodelPA(M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(YmodelPA));<br><br><span class="hljs-comment">%通过归一化均方误差衡量功放的建模精度</span><br>NMSE = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>( sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - YmodelFitPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(YmodelPA)).^<span class="hljs-number">2</span> ) ) ;<br><br><span class="hljs-comment">%计算未线性化的EVM</span><br>EVM_withoutDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - XmodelPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XmodelPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withoutDPD is &#x27;</span> num2str(EVM_withoutDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br><span class="hljs-comment">% paCharPlot(XmodelPA,YmodelPA,XmodelPA,&#x27;AM/AM&#x27;);</span><br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><span class="hljs-comment">% paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,&#x27;Gain&#x27;);</span><br><br><br><span class="hljs-comment">%观察频谱</span><br><span class="hljs-comment">%sa = helperPACharPlotSpectrum([YmodelPA  YmodelFitPA],&#123;&#x27;Actual PA Output&#x27;, &#x27;Model PA Output&#x27;&#125;, sampleRate,testSignal);</span><br><br><span class="hljs-comment">%预失真器建立</span><br><br><span class="hljs-comment">%预失真器参数提取</span><br>XcoefDPD = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>YcoefDPD = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefDPD = x(1:half);  %使用前一半数据估计参数，将数据归一化</span><br><span class="hljs-comment">% YcoefDPD = y(1:half);  </span><br><br>XcoefDPD = XcoefDPD(M+<span class="hljs-number">1</span>:half);                     <span class="hljs-comment">%将PA实际输入数据作为输出数据，取前一半数据</span><br>coefDPD = MatrixDeal(YcoefDPD,M,K) \ XcoefDPD;      <span class="hljs-comment">%计算得到DPD参数模型，与PA行为模型一致</span><br><br><span class="hljs-comment">%计算DPD模型输出</span><br>XmodelDPD = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );         <span class="hljs-comment">%使用后一半数据进行DPD模型验证</span><br>YmodelDPD = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><br><span class="hljs-comment">% XmodelDPD = x(half:xLength);         %使用后一半数据进行DPD模型验证</span><br><span class="hljs-comment">% YmodelDPD = y(half:xLength); </span><br><br>YmodelFitDPD = MatrixDeal(XmodelDPD,M,K) * coefDPD;  <span class="hljs-comment">%计算得到DPD输出（输出数据减少M个）</span><br><br><br><span class="hljs-comment">%去除多余数据</span><br><span class="hljs-comment">% %对比PA模型与DPD模型的非线性特性</span><br><span class="hljs-comment">% XmodelDPD = x(half+M:xLength,:);         %实际用于DPD模型验证的输入数据(去除前M个)</span><br><span class="hljs-comment">% YmodelDPD = y(half+M:yLength,:);         %实际的DPD模型的输出数据（去除前M个）</span><br><span class="hljs-comment">% paCharPlot(XmodelDPD,YmodelFitPA,YmodelFitDPD,&#x27;AM/AM&#x27;);</span><br><br><br><span class="hljs-comment">%将DPD模型输出，输入到PA模型中</span><br>Ylinear = MatrixDeal(YmodelFitDPD,M,K) * coefPA;<br><br><span class="hljs-comment">%计算误差向量幅度EVM</span><br>XDPDPA = XmodelDPD(M+M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(XmodelDPD));<br>YDPDPA = YmodelDPD(M+M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(YmodelDPD));<br><br>EVM_withDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(Ylinear - XDPDPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XDPDPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withDPD is &#x27;</span> num2str(EVM_withDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br><span class="hljs-comment">% % paCharPlot(XDPDPA,XDPDPA,Ylinear,&#x27;AM/AM&#x27;);</span><br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><span class="hljs-comment">% paCharPlot(XDPDPA,YDPDPA,Ylinear,&#x27;Gain&#x27;);</span><br><br><span class="hljs-comment">%邻信道功率比ACPR</span><br><span class="hljs-comment">%sa = helperPACharPlotSpectrum([YDPDPA  Ylinear],&#123;&#x27;Actual PA Output&#x27;, &#x27;with DPD Output&#x27;&#125;, sampleRate,testSignal);</span><br><br><br></code></pre></td></tr></table></figure><h4 id="2、DVR模型-1"><a href="#2、DVR模型-1" class="headerlink" title="2、DVR模型"></a>2、DVR模型</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%本例使用NXP Airfast LDMOS Doherty PA，工作频率3.6-3.8 GHz，增益29 dB。</span><br><span class="hljs-comment">%带宽100MHZ</span><br><span class="hljs-comment">%采样率sampleRate = 860160000</span><br><span class="hljs-comment">%信号类型OFDM</span><br><span class="hljs-comment">%If testSignal is &quot;OFDM&quot;, this example uses a 5G-like OFDM waveform with 64-QAM modulated signals for each subcarrier.</span><br><span class="hljs-comment">% If testSignal is &quot;Tones&quot;, this example uses two tones at 1.8 MHz and 2.6 MHz, to test the intermodulation caused by the PA.</span><br><br><br>sampleRate = <span class="hljs-number">860160000</span>;<br><span class="hljs-comment">% sampleRate = 430080000;</span><br>testSignal = <span class="hljs-string">&#x27;OFDM&#x27;</span>;<br><br><span class="hljs-comment">%读取数据</span><br><span class="hljs-comment">% x = (0 : 5);</span><br>x = paInput;<br><span class="hljs-comment">% x = txData1;</span><br><span class="hljs-comment">% x = paInput_40MHZ;</span><br>x = x(:);<br>xLength = <span class="hljs-built_in">length</span>(x);<br><span class="hljs-comment">%使用前半部分数据用于参数提取，后半部分数据用于模型验证</span><br>half = <span class="hljs-built_in">round</span>(xLength/<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% y = (2 : 7);</span><br>y = paOutput;<br><span class="hljs-comment">% y = tout;</span><br><span class="hljs-comment">% y = paOutput_40MHZ;</span><br>y = y(:);<br>yLength = <span class="hljs-built_in">length</span>(y);<br><br><span class="hljs-comment">%将数据归一化</span><br><span class="hljs-comment">% x = x / abs(max(x));</span><br><span class="hljs-comment">% y = y / abs(max(y));</span><br><br><br><br>M = <span class="hljs-number">2</span>;<br>K = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">%计算PA系数矩阵，矩阵大小为（M*K*4+M） * 1</span><br><br><span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>XcoefPA = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <br>YcoefPA = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefPA = x(1:half);  </span><br><span class="hljs-comment">% YcoefPA = y(1:half);  </span><br><br><span class="hljs-comment">%去除多余数据</span><br>YcoefPA = YcoefPA(M+<span class="hljs-number">1</span>:half) ;                   <span class="hljs-comment">%经过处理后，数据去除掉前M个</span><br>coefPA = MatrixDeal_DVR(XcoefPA,M,K) \ YcoefPA;<br><br><span class="hljs-comment">%最小二乘算法</span><br><span class="hljs-comment">% coefPA  = inv( (XcoefPA&#x27;) *XcoefPA ) * (XcoefPA&#x27;) * YcoefPA;</span><br><span class="hljs-comment">% coefPA  = ( (XcoefPA&#x27;) *XcoefPA ) \ (XcoefPA&#x27;) * YcoefPA;</span><br><br><span class="hljs-comment">%带入验证PA模型输出，矩阵大小为xLength*1</span><br>XmodelPA = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );      <span class="hljs-comment">%使用后一半的数据验证模型，将数据归一化</span><br>YmodelPA = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><br><span class="hljs-comment">% XmodelPA = x(half:xLength);      %使用后一半的数据验证模型，将数据归一化</span><br><span class="hljs-comment">% YmodelPA = y(half:xLength); </span><br><br>YmodelFitPA = MatrixDeal_DVR(XmodelPA,M,K) * coefPA;   <span class="hljs-comment">%计算模型输出（输出后的数据减少前M个）</span><br><br><span class="hljs-comment">%去除多余数据</span><br>XmodelPA = XmodelPA(M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(XmodelPA));<br>YmodelPA = YmodelPA(M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(YmodelPA));<br><br><span class="hljs-comment">%通过归一化均方误差衡量功放的建模精度</span><br>NMSE = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>( sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - YmodelFitPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(YmodelPA)).^<span class="hljs-number">2</span> ) ) ;<br><br><span class="hljs-comment">%计算未线性化的EVM</span><br>EVM_withoutDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - XmodelPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XmodelPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withoutDPD is &#x27;</span> num2str(EVM_withoutDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br><span class="hljs-comment">% paCharPlot(XmodelPA,YmodelPA,XmodelPA,&#x27;AM/AM&#x27;);</span><br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><br><br><span class="hljs-comment">%观察频谱</span><br><span class="hljs-comment">%sa = helperPACharPlotSpectrum([YmodelPA  YmodelFitPA],&#123;&#x27;Actual PA Output&#x27;, &#x27;Model PA Output&#x27;&#125;, sampleRate,testSignal);</span><br><br><br><span class="hljs-comment">%预失真器建立</span><br><br><span class="hljs-comment">%预失真器参数提取</span><br>XcoefDPD = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>YcoefDPD = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefDPD = x(1:half);  %使用前一半数据估计参数，将数据归一化</span><br><span class="hljs-comment">% YcoefDPD = y(1:half);  </span><br><br>XcoefDPD = XcoefDPD(M+<span class="hljs-number">1</span>:half);                     <span class="hljs-comment">%将PA实际输入数据作为输出数据，取前一半数据</span><br>coefDPD = MatrixDeal_DVR(YcoefDPD,M,K) \ XcoefDPD;      <span class="hljs-comment">%计算得到DPD参数模型，与PA行为模型一致</span><br><br><span class="hljs-comment">%计算DPD模型输出</span><br>XmodelDPD = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );         <span class="hljs-comment">%使用后一半数据进行DPD模型验证</span><br>YmodelDPD = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><br><span class="hljs-comment">% XmodelDPD = x(half:xLength);         %使用后一半数据进行DPD模型验证</span><br><span class="hljs-comment">% YmodelDPD = y(half:xLength); </span><br><br>YmodelFitDPD = MatrixDeal_DVR(XmodelDPD,M,K) * coefDPD;  <span class="hljs-comment">%计算得到DPD输出（输出数据减少M个）</span><br><br><br><span class="hljs-comment">%去除多余数据</span><br><span class="hljs-comment">% %对比PA模型与DPD模型的非线性特性</span><br><span class="hljs-comment">% XmodelDPD = x(half+M:xLength,:);         %实际用于DPD模型验证的输入数据(去除前M个)</span><br><span class="hljs-comment">% YmodelDPD = y(half+M:yLength,:);         %实际的DPD模型的输出数据（去除前M个）</span><br><span class="hljs-comment">% paCharPlot(XmodelDPD,YmodelFitPA,YmodelFitDPD,&#x27;AM/AM&#x27;);</span><br><br><br><span class="hljs-comment">%将DPD模型输出，输入到PA模型中</span><br>Ylinear = MatrixDeal_DVR(YmodelFitDPD,M,K) * coefPA;<br><br><span class="hljs-comment">%计算误差向量幅度EVM</span><br>XDPDPA = XmodelDPD(M+M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(XmodelDPD));<br>YDPDPA = YmodelDPD(M+M+<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(YmodelDPD));<br><br>EVM_withDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(Ylinear - XDPDPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XDPDPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withDPD is &#x27;</span> num2str(EVM_withDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br><span class="hljs-comment">% paCharPlot(XDPDPA,XDPDPA,Ylinear,&#x27;AM/AM&#x27;);</span><br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><br><span class="hljs-comment">%邻信道功率比ACPR</span><br><span class="hljs-comment">%sa = helperPACharPlotSpectrum([YDPDPA  Ylinear],&#123;&#x27;Actual PA Output&#x27;, &#x27;with DPD Output&#x27;&#125;, sampleRate,testSignal);</span><br><br><br></code></pre></td></tr></table></figure><h4 id="3、MP模型"><a href="#3、MP模型" class="headerlink" title="3、MP模型"></a>3、MP模型</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% % 为了表征AM/AM传递函数，计算输入功率值范围内的平均输出功率。</span><br><span class="hljs-comment">% % 测量的单位是伏，总体阻抗为100欧姆，</span><br><span class="hljs-comment">% % 在发射器和接收器之间划分。</span><br><span class="hljs-comment">% % 将测量的基带样本转换为dBm的功率值。</span><br><span class="hljs-comment">% % +30 dB项用于dBW到dBm的转换，</span><br><span class="hljs-comment">% % -20 dB项用于100欧姆阻抗。</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% %mag2db函数用于将振幅转换为dB </span><br><span class="hljs-comment">% %原始输入输出数据是复数，绝对值转换为功率</span><br><span class="hljs-comment">% paInputdBm  = mag2db(abs(paInput)) + 30 - 20;</span><br><span class="hljs-comment">% paOutputdBm  = mag2db(abs(paOutput)) + 30 - 20;</span><br><br><br><span class="hljs-comment">% modType = &#x27;memPoly&#x27;;</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% memLen = 3;</span><br><span class="hljs-comment">% degLen = 5;</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% numDataPts = length(paInput);</span><br><span class="hljs-comment">% halfDataPts = round(numDataPts/2);</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% fitCoefMatMem = helperPACharMemPolyModel(&#x27;coefficientFinder&#x27;, paInput(1:halfDataPts),paOutput(1:halfDataPts),memLen,degLen,modType);</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% disp(abs(fitCoefMatMem));</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% rmsErrorTimeMem = helperPACharMemPolyModel(&#x27;errorMeasure&#x27;, paInput, paOutput, fitCoefMatMem, modType);</span><br><span class="hljs-comment">% </span><br><span class="hljs-comment">% disp([&#x27;Percent RMS error in time domain is &#x27; num2str(rmsErrorTimeMem) &#x27;%&#x27;]);</span><br><span class="hljs-comment">% paOutputFitMem = helperPACharMemPolyModel(&#x27;signalGenerator&#x27;,  paInput, fitCoefMatMem, modType);</span><br><span class="hljs-comment">%   </span><br><span class="hljs-comment">% helperPACharPlotTime(paOutput, paOutputFitMem, sampleRate);</span><br><span class="hljs-comment">% helperPACharPlotGain(paInput, paOutput, paOutputFitMem);</span><br><br><br><br><br><span class="hljs-comment">%本例使用NXP Airfast LDMOS Doherty PA，工作频率3.6-3.8 GHz，增益29 dB。</span><br><span class="hljs-comment">%带宽100MHZ</span><br><span class="hljs-comment">%采样率sampleRate = 860160000</span><br><span class="hljs-comment">%信号类型OFDM</span><br><span class="hljs-comment">%If testSignal is &quot;OFDM&quot;, this example uses a 5G-like OFDM waveform with 64-QAM modulated signals for each subcarrier.</span><br><span class="hljs-comment">% If testSignal is &quot;Tones&quot;, this example uses two tones at 1.8 MHz and 2.6 MHz, to test the intermodulation caused by the PA.</span><br><br><br>sampleRate = <span class="hljs-number">860160000</span>;<br><span class="hljs-comment">% sampleRate = 430080000;</span><br>testSignal = <span class="hljs-string">&#x27;OFDM&#x27;</span>;<br><br><span class="hljs-comment">%读取数据</span><br><span class="hljs-comment">% x = (0 : 5);</span><br>x = paInput;<br><span class="hljs-comment">% x = txData1;</span><br><span class="hljs-comment">% x = paInput_40MHZ;</span><br>x = x(:);<br>xLength = <span class="hljs-built_in">length</span>(x);<br><span class="hljs-comment">%使用前半部分数据用于参数提取，后半部分数据用于模型验证</span><br>half = <span class="hljs-built_in">round</span>(xLength/<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% y = (2 : 7);</span><br>y = paOutput;<br><span class="hljs-comment">% y = tout;</span><br><span class="hljs-comment">% y = paOutput_40MHZ;</span><br>y = y(:);<br>yLength = <span class="hljs-built_in">length</span>(y);<br><br><span class="hljs-comment">%将数据归一化</span><br><span class="hljs-comment">% x = x / abs(max(x));</span><br><span class="hljs-comment">% y = y / abs(max(y));</span><br><br>M = <span class="hljs-number">2</span>;<br>K = <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">%使用前一半数据用于PA参数提取</span><br>XcoefPA = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <br>YcoefPA = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefPA = x(1:half);  </span><br><span class="hljs-comment">% YcoefPA = y(1:half);  </span><br><br>YcoefPA = YcoefPA(M:half) ;                   <span class="hljs-comment">%经过处理后，数据去除掉前M个</span><br>coefPA = MatrixDeal_MP(XcoefPA,M,K) \ YcoefPA;<br><br><span class="hljs-comment">%使用后一半数据用于PA模型验证</span><br>XmodelPA = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );      <span class="hljs-comment">%使用后一半的数据验证模型，将数据归一化</span><br>YmodelPA = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><span class="hljs-comment">% XmodelPA = x(half:xLength);      %使用后一半的数据验证模型，将数据归一化</span><br><span class="hljs-comment">% YmodelPA = y(half:xLength); </span><br><br>YmodelFitPA = MatrixDeal_MP(XmodelPA,M,K) * coefPA;   <span class="hljs-comment">%计算模型输出（输出后的数据减少前M个）</span><br><br><span class="hljs-comment">%去除多余数据</span><br>XmodelPA = XmodelPA(M:<span class="hljs-built_in">length</span>(XmodelPA));<br>YmodelPA = YmodelPA(M:<span class="hljs-built_in">length</span>(YmodelPA));<br><br><span class="hljs-comment">%计算未线性化的EVM</span><br>EVM_withoutDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - XmodelPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XmodelPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withoutDPD is &#x27;</span> num2str(EVM_withoutDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%计算NMSE</span><br>NMSE = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>( sum ( (<span class="hljs-built_in">abs</span>(YmodelPA - YmodelFitPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(YmodelPA)).^<span class="hljs-number">2</span> ) ) ;<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br>paCharPlot(XmodelPA,YmodelPA,YmodelFitPA,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><br><br><br><span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>XcoefDPD = x(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(<span class="hljs-number">1</span>:half)) );  <span class="hljs-comment">%使用前一半数据估计参数，将数据归一化</span><br>YcoefDPD = y(<span class="hljs-number">1</span>:half) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(<span class="hljs-number">1</span>:half)) );  <br><br><span class="hljs-comment">% XcoefDPD = x(1:half);  %使用前一半数据估计参数，将数据归一化</span><br><span class="hljs-comment">% YcoefDPD = y(1:half);  </span><br><br><br>XcoefDPD = XcoefDPD(M:half);                     <span class="hljs-comment">%将PA实际输入数据作为输出数据，取前一半数据</span><br>coefDPD = MatrixDeal_MP(YcoefDPD,M,K) \ XcoefDPD;      <span class="hljs-comment">%计算得到DPD参数模型，与PA行为模型一致</span><br><br><br><span class="hljs-comment">%模型验证</span><br>XmodelDPD = x(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(x(half:xLength)) );         <span class="hljs-comment">%使用后一半数据进行DPD模型验证</span><br>YmodelDPD = y(half:xLength) / <span class="hljs-built_in">abs</span> ( <span class="hljs-built_in">max</span>(y(half:xLength)) ); <br><br><span class="hljs-comment">% XmodelDPD = x(half:xLength);         %使用后一半数据进行DPD模型验证</span><br><span class="hljs-comment">% YmodelDPD = y(half:xLength); </span><br><br>YmodelFitDPD = MatrixDeal_MP(XmodelDPD,M,K) * coefDPD;  <span class="hljs-comment">%计算得到DPD输出（输出数据减少M个）</span><br><br>Ylinear = MatrixDeal_MP(YmodelFitDPD,M,K) * coefPA;<br><br><span class="hljs-comment">%计算误差向量幅度EVM</span><br>XDPDPA = XmodelDPD(M+M<span class="hljs-number">-1</span>:<span class="hljs-built_in">length</span>(XmodelDPD));<br>YDPDPA = YmodelDPD(M+M<span class="hljs-number">-1</span>:<span class="hljs-built_in">length</span>(YmodelDPD));<br><br>EVM_withDPD = <span class="hljs-built_in">sqrt</span> (  sum ( (<span class="hljs-built_in">abs</span>(Ylinear - XDPDPA)).^<span class="hljs-number">2</span> ) / sum ( (<span class="hljs-built_in">abs</span>(XDPDPA)).^<span class="hljs-number">2</span>) ) * <span class="hljs-number">100</span> ;<br><span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;The EVM_withDPD is &#x27;</span> num2str(EVM_withDPD) <span class="hljs-string">&#x27;%&#x27;</span>]);<br><br><span class="hljs-comment">%绘图</span><br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;AM/AM&#x27;</span>);<br>paCharPlot(XDPDPA,YDPDPA,Ylinear,<span class="hljs-string">&#x27;PM/AM&#x27;</span>);<br><br><span class="hljs-comment">%邻信道功率比ACPR</span><br>sa = helperPACharPlotSpectrum([YDPDPA  Ylinear],&#123;<span class="hljs-string">&#x27;Actual PA Output&#x27;</span>, <span class="hljs-string">&#x27;with DPD Output&#x27;</span>&#125;, sampleRate,testSignal);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/25/hello-world/"/>
    <url>/2023/06/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Helloworld</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
